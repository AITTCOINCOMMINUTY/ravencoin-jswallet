{"mappings":"AAUA;IACE,SAAS,EAAE,MAAM,CAAC;IAClB,QAAQ,EAAE,MAAM,CAAC;IACjB,IAAI,EAAE,MAAM,CAAC;IACb,KAAK,EAAE,MAAM,CAAC;IACd,UAAU,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,MAAM,CAAC;IACf,OAAO,EAAE,MAAM,CAAC;CACjB;AACD;IACE,aAAa,EAAE,MAAM,CAAC;IACtB,KAAK,EAAE,GAAG,CAAC;CACZ;AAuGD;IACE,OAAO,EAAE,MAAM,CAAC;IAChB,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,EAAE,MAAM,CAAC;IACb,UAAU,EAAE,MAAM,CAAC;CACpB;AAuBD;IACE,OAAO,EAAE,MAAM,CAAC;IAChB,GAAG,EAAE,MAAM,CAAC;IACZ,IAAI,EAAE,MAAM,CAAC;IACb,UAAU,EAAE,MAAM,CAAC;CACpB;AIjJD;IACE,SAAS,CAAC,EAAE,MAAM,CAAC;IACnB,SAAS,EAAE,MAAM,CAAC;IAClB,MAAM,EAAE,MAAM,CAAC;CAChB;AAKD;IACE,GAAG,kDAAiD;IACpD,SAAS,SAAM;IAEf,cAAc,EAAE,KAAK,CAAC,gBAAgB,CAAC,CAAM;IAC7C,cAAc,SAAM;IACpB,eAAe,SAAK;IAEpB,iBAAiB;IAGjB,YAAY,IAAI,KAAK,CAAC,MAAM,CAAC;IAOvB,IAAI,CAAC,OAAO,EAAE,QAAQ;IAoDtB,UAAU,CAAC,SAAS,EAAE,KAAK,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,OAAO,CAAC;IAStD,sBAAsB,CAAC,QAAQ,EAAE,OAAO;IAmCxC,UAAU,IAAI,OAAO,CAAC,aAAa,EAAE,CAAC;IAMtC,iBAAiB;IAKjB,gBAAgB;IAIhB,QAAQ;IAMd,sBAAsB,CAAC,OAAO,EAAE,MAAM;IAShC,IAAI,CAAC,OAAO,EAAE,KAAK,GAAG,OAAO,CAAC,WAAW,CAAC;IAgI1C,SAAS;IAWT,UAAU;CAOjB;;;;AAED,wBAEE;AACF,+BAAqC,OAAO,EAAE,QAAQ,mBAIrD;AAED;IACE,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,QAAQ,EAAE,MAAM,CAAC;IACjB,OAAO,CAAC,EAAE,KAAK,GAAG,UAAU,CAAC;CAC9B","sources":["src/src/Types.ts","src/src/blockchain/blockchain.ts","src/src/contants.ts","src/src/blockchain/Transactor.ts","src/src/ravencoinWallet.ts","src/ravencoinWallet.ts"],"sourcesContent":[null,null,null,null,null,"const bitcore = require(\"bitcore-lib\");\nconst coininfo = require(\"coininfo\");\nimport * as blockchain from \"./blockchain/blockchain\";\nimport { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\nimport { IAddressDelta, IAddressMetaData, ISendResult, IUTXO } from \"./Types\";\nimport { ONE_FULL_COIN } from \"./contants\";\n\nimport * as Transactor from \"./blockchain/Transactor\";\n\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\n\ninterface ISend {\n  assetName?: string;\n  toAddress: string;\n  amount: number;\n}\n\n//Avoid singleton (anti-pattern)\n//Meaning multiple instances of the wallet must be able to co-exist\n\nclass Wallet {\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\n  _mnemonic = \"\";\n\n  addressObjects: Array<IAddressMetaData> = [];\n  receiveAddress = \"\";\n  addressPosition = 0;\n\n  getAddressObjects() {\n    return this.addressObjects;\n  }\n  getAddresses(): Array<string> {\n    const addresses = this.addressObjects.map((obj) => {\n      return obj.address;\n    });\n    return addresses;\n  }\n\n  async init(options: IOptions) {\n    let username = \"anonymous\";\n    let password = \"anonymous\";\n    let url = URL_MAINNET;\n\n    //VALIDATION\n    if (!options) {\n      throw Error(\"option argument is mandatory\");\n    }\n\n    if (!options.mnemonic) {\n      throw Error(\"option.mnemonic is mandatory\");\n    }\n\n    url = options.rpc_url || url;\n    password = options.rpc_password || url;\n    username = options.rpc_username || url;\n\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\n      url = URL_TESTNET;\n    }\n\n    this.rpc = getRPC(username, password, url);\n    //DERIVE ADDRESSES BIP44, external 20 unused (that is no history, not no balance)\n    //TODO improve performance by creating blocks of 20 addresses and check history for all 20 at once\n    //That is one history lookup intead of 20\n    this._mnemonic = options.mnemonic;\n    let isLast20ExternalAddressesUnused = false;\n    const ACCOUNT = 0;\n    const network = options.network || \"rvn\";\n\n    while (isLast20ExternalAddressesUnused === false) {\n      const tempAddresses = [] as string[];\n\n      for (let i = 0; i < 20; i++) {\n        const o = RavencoinKey.getAddressPair(\n          network,\n          this._mnemonic,\n          ACCOUNT,\n          this.addressPosition\n        );\n        this.addressObjects.push(o.external);\n        this.addressObjects.push(o.internal);\n        this.addressPosition++;\n\n        tempAddresses.push(o.external.address + \"\");\n      }\n      //If no history, break\n      isLast20ExternalAddressesUnused =\n        false === (await this.hasHistory(tempAddresses));\n    }\n  }\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\n    const includeAssets = true;\n    const obj = {\n      addresses,\n    };\n    const asdf = await this.rpc(methods.getaddresstxids, [obj, includeAssets]);\n    return asdf.length > 0;\n  }\n\n  async _getFirstUnusedAddress(external: boolean) {\n    //First, check if lastReveivedAddress\n    if (external === true && this.receiveAddress) {\n      const asdf = await this.hasHistory([this.receiveAddress]);\n      if (asdf === false) {\n        console.log(\"Receive address no need to change\");\n        return this.receiveAddress;\n      }\n    }\n\n    const addresses = this.getAddresses();\n    //even addresses are external, odd address are internal/changes\n\n    for (let counter = 0; counter < addresses.length; counter++) {\n      if (external && counter % 2 !== 0) {\n        continue;\n      }\n      const address = addresses[counter];\n\n      //If an address has tenth of thousands of transactions, getHistory will throw an exception\n\n      const asdf = await this.hasHistory([address]);\n\n      if (asdf === false) {\n        if (external === true) {\n          this.receiveAddress = address;\n        }\n        return address;\n      }\n    }\n\n    //IF we have not found one, return the first address\n    return addresses[0];\n  }\n\n  async getMempool(): Promise<IAddressDelta[]> {\n    const method = methods.getaddressmempool;\n    const includeAssets = true;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    return this.rpc(method, params);\n  }\n  async getReceiveAddress() {\n    const isExternal = true;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n\n  async getChangeAddress() {\n    const isExternal = false;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n  async getUTXOs() {\n    return this.rpc(methods.getaddressutxos, [\n      { addresses: this.getAddresses() },\n    ]);\n  }\n\n  getPrivateKeyByAddress(address: string) {\n    const f = this.addressObjects.find((a) => a.address === address);\n\n    if (!f) {\n      return undefined;\n    }\n    return f.WIF;\n  }\n\n  async send(options: ISend): Promise<ISendResult> {\n    const { amount, assetName, toAddress } = options;\n\n    //Validation\n    if (!toAddress) {\n      throw Error(\"Wallet.send  toAddress is mandatory\");\n    }\n    if (!amount) {\n      throw Error(\"Wallet.send  amount is mandatory\");\n    }\n\n    if (assetName && assetName !== \"RVN\") {\n      return Transactor.send(\n        this.rpc,\n        this.addressObjects,\n        toAddress,\n        amount,\n        assetName\n      );\n    } else {\n      return this._sendRavencoin(toAddress, amount);\n    }\n  }\n  private async _sendRavencoin(\n    toAddress: string,\n    amount: number\n  ): Promise<ISendResult> {\n    if (amount < 0) {\n      throw Error(\"Amount cannot be negative\");\n    }\n    if (!toAddress) {\n      throw Error(\"toAddress seems invalid\");\n    }\n\n    const addresses = this.getAddresses();\n    const sendResult: ISendResult = {\n      transactionId: \"\",\n      debug: {},\n    };\n    //Add Ravencoin as Network to BITCORE\n    //@ts-ignore\n    const d = coininfo.ravencoin.main.toBitcore();\n    d.name = \"ravencoin\";\n    d.alias = \"RVN\";\n    bitcore.Networks.add(d);\n\n    //According to the source file bitcore.Networks.get has two arguments, the second argument keys is OPTIONAL\n    //The TypescriptTypes says that the second arguments is mandatory, so ignore that\n    //@ts-ignore\n    const ravencoin = bitcore.Networks.get(\"RVN\");\n\n    //GET UNSPET OUTPUTS (UTXO)\n    //Configure RPC bridge\n\n    const balance = await this.rpc(methods.getaddressbalance, [\n      { addresses: addresses },\n    ]);\n    if (balance.balance) {\n      const b = balance.balance / ONE_FULL_COIN;\n\n      if (b < amount) {\n        throw Error(\"Not enough money, \" + b);\n      }\n    }\n\n    //GET UNSPENT TRANSACTION OUTPUTS\n    let allUnspent = await this.getUTXOs();\n\n    const mempool = await blockchain.getMempool(this.rpc);\n\n    //Filter out UTXOs currently in mempool\n    allUnspent = allUnspent.filter(\n      (UTXO) => Transactor.isUTXOInMempool(mempool, UTXO) === false\n    );\n\n    //GET ENOUGH UTXOs FOR THIS TRANSACTION\n    const unspent = Transactor.getEnoughUTXOs(\n      allUnspent,\n      amount + 1 /*to cover the fee*/\n    );\n    if (unspent.length === 0) {\n      throw Error(\"No unspent transactions outputs\");\n    }\n    console.log(\"Will use\", unspent.length, \"UTXO to send\", amount);\n    let amo = 0;\n    unspent.map((utxo) => (amo += utxo.satoshis / 1e8));\n    console.log(\"Amount of UTXO\", amo);\n    const transaction = new bitcore.Transaction();\n\n    const utxoObjects = unspent.map(\n      (u) => new bitcore.Transaction.UnspentOutput(u)\n    );\n\n    const changeAddress = await this._getFirstUnusedAddress(false);\n\n    const privateKeys = utxoObjects.map((utxo) => {\n      const addy = utxo.address.toString();\n      const key = this.getPrivateKeyByAddress(addy);\n      const privateKey = new bitcore.PrivateKey(key);\n\n      return privateKey;\n    });\n\n    transaction.from(utxoObjects);\n    transaction.to(toAddress, amount * ONE_FULL_COIN);\n    transaction.change(changeAddress);\n\n    //UPDATE FEE\n    transaction.fee(transaction.getFee() * 100);\n    sendResult.debug.fee = transaction.getFee() * 100;\n\n    console.log(\n      \"OK want to send\",\n      amount,\n      \"has got\",\n      amo,\n      \"and fee is\",\n      transaction.getFee() / 1e8\n    );\n    transaction.sign(privateKeys);\n\n    const id = await this.rpc(methods.sendrawtransaction, [\n      transaction.serialize(),\n    ]);\n\n    sendResult.transactionId = id;\n    return sendResult;\n  }\n  async getAssets() {\n    const includeAssets = true;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    const balance = await this.rpc(methods.getaddressbalance, params);\n\n    //Remove RVN\n    const result = balance.filter((obj) => {\n      return obj.assetName !== \"RVN\";\n    });\n    return result;\n  }\n  async getBalance() {\n    const includeAssets = false;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    const balance = await this.rpc(methods.getaddressbalance, params);\n\n    return balance.balance / ONE_FULL_COIN;\n  }\n}\n\nexport default {\n  createInstance,\n};\nexport async function createInstance(options: IOptions) {\n  const wallet = new Wallet();\n  await wallet.init(options);\n  return wallet;\n}\n\nexport interface IOptions {\n  rpc_username?: string;\n  rpc_password?: string;\n  rpc_url?: string;\n  mnemonic: string;\n  network?: \"rvn\" | \"rvn-test\";\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}