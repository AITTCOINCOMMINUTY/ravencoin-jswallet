{"mappings":"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","sources":["src/src/Types.ts","src/src/contants.ts","src/src/blockchain/blockchain.ts","src/src/Errors.ts","src/src/blockchain/Transactor.ts","src/src/blockchain/sweep.ts","src/src/ravencoinWallet.ts","src/ravencoinWallet.ts"],"sourcesContent":[null,null,null,null,null,null,null,"import { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\r\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\r\nimport {\r\n  ChainType,\r\n  IAddressDelta,\r\n  IAddressMetaData,\r\n  ISend,\r\n  ISendInternalProps,\r\n  ISendResult,\r\n  SweepResult,\r\n} from \"./Types\";\r\nimport { ONE_FULL_COIN } from \"./contants\";\r\n\r\nimport * as Transactor from \"./blockchain/Transactor\";\r\n\r\nimport { sweep } from \"./blockchain/sweep\";\r\n\r\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\r\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\r\n\r\n//Avoid singleton (anti-pattern)\r\n//Meaning multiple instances of the wallet must be able to co-exist\r\n\r\nexport class Wallet {\r\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\r\n  _mnemonic = \"\";\r\n  network: ChainType = \"rvn\";\r\n  addressObjects: Array<IAddressMetaData> = [];\r\n  receiveAddress = \"\";\r\n  changeAddress = \"\";\r\n  addressPosition = 0;\r\n  baseCurrency = \"RVN\"; //Default is RVN but it could be EVR\r\n  offlineMode = false;\r\n  setBaseCurrency(currency: string) {\r\n    this.baseCurrency = currency;\r\n  }\r\n  getBaseCurrency() {\r\n    return this.baseCurrency;\r\n  }\r\n  /**\r\n   * Sweeping a private key means to send all the funds the address holds to your your wallet.\r\n   * The private key you sweep do not become a part of your wallet.\r\n   *\r\n   * NOTE: the address you sweep needs to cointain enough RVN to pay for the transaction\r\n   *\r\n   * @param WIF the private key of the address that you want move funds from\r\n   * @returns either a string, that is the transaction id or null if there were no funds to send\r\n   */\r\n  sweep(WIF: string, onlineMode: boolean): Promise<SweepResult> {\r\n    const wallet = this;\r\n\r\n    return sweep(WIF, wallet, onlineMode);\r\n  }\r\n  getAddressObjects() {\r\n    return this.addressObjects;\r\n  }\r\n  getAddresses(): Array<string> {\r\n    const addresses = this.addressObjects.map((obj) => {\r\n      return obj.address;\r\n    });\r\n    return addresses;\r\n  }\r\n\r\n  async init(options: IOptions) {\r\n    let username = \"anonymous\";\r\n    let password = \"anonymous\";\r\n    let url = URL_MAINNET;\r\n\r\n    //VALIDATION\r\n    if (!options) {\r\n      throw Error(\"option argument is mandatory\");\r\n    }\r\n\r\n    if (options.offlineMode === true) {\r\n      this.offlineMode = true;\r\n    }\r\n    if (!options.mnemonic) {\r\n      throw Error(\"option.mnemonic is mandatory\");\r\n    }\r\n\r\n    url = options.rpc_url || url;\r\n    password = options.rpc_password || url;\r\n    username = options.rpc_username || url;\r\n\r\n    if (options.network) {\r\n      this.network = options.network;\r\n      this.setBaseCurrency(getBaseCurrencyByNetwork(options.network));\r\n    }\r\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\r\n      url = URL_TESTNET;\r\n    }\r\n\r\n    this.rpc = getRPC(username, password, url);\r\n    //DERIVE ADDRESSES BIP44, external 20 unused (that is no history, not no balance)\r\n    //TODO improve performance by creating blocks of 20 addresses and check history for all 20 at once\r\n    //That is one history lookup intead of 20\r\n    this._mnemonic = options.mnemonic;\r\n\r\n    const ACCOUNT = 0;\r\n\r\n    //Should we create an extra amount of addresses at startup?\r\n    if (options.minAmountOfAddresses) {\r\n      for (let i = 0; i < options.minAmountOfAddresses; i++) {\r\n        const o = RavencoinKey.getAddressPair(\r\n          this.network,\r\n          this._mnemonic,\r\n          ACCOUNT,\r\n          this.addressPosition\r\n        );\r\n        this.addressObjects.push(o.external);\r\n        this.addressObjects.push(o.internal);\r\n        this.addressPosition++;\r\n      }\r\n    }\r\n\r\n    let isLast20ExternalAddressesUnused = false;\r\n    while (isLast20ExternalAddressesUnused === false) {\r\n      const tempAddresses = [] as string[];\r\n\r\n      for (let i = 0; i < 20; i++) {\r\n        const o = RavencoinKey.getAddressPair(\r\n          this.network,\r\n          this._mnemonic,\r\n          ACCOUNT,\r\n          this.addressPosition\r\n        );\r\n        this.addressObjects.push(o.external);\r\n        this.addressObjects.push(o.internal);\r\n        this.addressPosition++;\r\n\r\n        tempAddresses.push(o.external.address + \"\");\r\n        tempAddresses.push(o.internal.address + \"\");\r\n      }\r\n\r\n      if (this.offlineMode === true) {\r\n        //BREAK generation of addresses and do NOT check history on the network\r\n        isLast20ExternalAddressesUnused = true;\r\n      } else {\r\n        //If no history, break\r\n        isLast20ExternalAddressesUnused =\r\n          false === (await this.hasHistory(tempAddresses));\r\n      }\r\n    }\r\n  }\r\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\r\n    const includeAssets = true;\r\n    const obj = {\r\n      addresses,\r\n    };\r\n\r\n    const asdf = (await this.rpc(methods.getaddressbalance, [\r\n      obj,\r\n      includeAssets,\r\n    ])) as any;\r\n\r\n    //@ts-ignore\r\n    const hasReceived = Object.values(asdf).find((asset) => asset.received > 0);\r\n\r\n    return !!hasReceived;\r\n  }\r\n\r\n  async _getFirstUnusedAddress(external: boolean) {\r\n    //First, check if lastReceivedAddress\r\n    if (external === true && this.receiveAddress) {\r\n      const asdf = await this.hasHistory([this.receiveAddress]);\r\n      if (asdf === false) {\r\n        return this.receiveAddress;\r\n      }\r\n    }\r\n    if (external === false && this.changeAddress) {\r\n      const asdf = await this.hasHistory([this.changeAddress]);\r\n      if (asdf === false) {\r\n        return this.changeAddress;\r\n      }\r\n    }\r\n\r\n    const addresses = this.getAddresses();\r\n    //even addresses are external, odd address are internal/changes\r\n\r\n    for (let counter = 0; counter < addresses.length; counter++) {\r\n      if (external && counter % 2 !== 0) {\r\n        continue;\r\n      }\r\n      const address = addresses[counter];\r\n\r\n      //If an address has tenth of thousands of transactions, getHistory will throw an exception\r\n\r\n      const hasHistory = await this.hasHistory([address]);\r\n\r\n      if (hasHistory === false) {\r\n        if (external === true) {\r\n          this.receiveAddress = address;\r\n        }\r\n        return address;\r\n      }\r\n    }\r\n\r\n    //IF we have not found one, return the first address\r\n    return addresses[0];\r\n  }\r\n\r\n  async getHistory(): Promise<IAddressDelta[]> {\r\n    const assetName = \"\"; //Must be empty string, NOT \"*\"\r\n    const addresses = this.getAddresses();\r\n    const deltas = this.rpc(methods.getaddressdeltas, [\r\n      { addresses, assetName },\r\n    ]);\r\n    return deltas;\r\n  }\r\n  async getMempool(): Promise<IAddressDelta[]> {\r\n    const method = methods.getaddressmempool;\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    return this.rpc(method, params) as Promise<IAddressDelta[]>;\r\n  }\r\n  async getReceiveAddress() {\r\n    const isExternal = true;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n\r\n  async getChangeAddress() {\r\n    const isExternal = false;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n  /**\r\n   *\r\n   * @param assetName if present, only return UTXOs for that asset, otherwise for all assets\r\n   * @returns UTXOs for assets\r\n   */\r\n  async getAssetUTXOs(assetName?: string) {\r\n    //If no asset name, set to wildcard, meaning all assets\r\n    const _assetName = !assetName ? \"*\" : assetName;\r\n    const chainInfo = false;\r\n    const params = [\r\n      { addresses: this.getAddresses(), chainInfo, assetName: _assetName },\r\n    ];\r\n\r\n    return this.rpc(methods.getaddressutxos, params);\r\n  }\r\n  async getUTXOs() {\r\n    return this.rpc(methods.getaddressutxos, [\r\n      { addresses: this.getAddresses() },\r\n    ]);\r\n  }\r\n\r\n  getPrivateKeyByAddress(address: string) {\r\n    const f = this.addressObjects.find((a) => a.address === address);\r\n\r\n    if (!f) {\r\n      return undefined;\r\n    }\r\n    return f.WIF;\r\n  }\r\n\r\n  async send(options: ISend): Promise<ISendResult> {\r\n    const { amount, toAddress } = options;\r\n    let { assetName } = options;\r\n\r\n    if (!assetName) {\r\n      assetName = this.baseCurrency;\r\n    }\r\n    const changeAddress = await this.getChangeAddress();\r\n\r\n    //Find the first change address after change address (emergency take the first).\r\n    const addresses = this.getAddresses();\r\n    let index = addresses.indexOf(changeAddress);\r\n    if (index > addresses.length - 2) {\r\n      index = 1;\r\n    }\r\n    if (index === -1) {\r\n      index = 1;\r\n    }\r\n    const changeAddressAssets = addresses[index + 2];\r\n\r\n    if (changeAddressAssets === changeAddress) {\r\n      throw Error(\r\n        \"Internal Error, changeAddress and changeAddressAssets cannot be the same\"\r\n      );\r\n    }\r\n\r\n    //Validation\r\n    if (!toAddress) {\r\n      throw Error(\"Wallet.send toAddress is mandatory\");\r\n    }\r\n    if (!amount) {\r\n      throw Error(\"Wallet.send amount is mandatory\");\r\n    }\r\n\r\n    if (changeAddress === toAddress) {\r\n      throw Error(\r\n        \"Wallet.send change address cannot be the same as toAddress \" +\r\n          changeAddress\r\n      );\r\n    }\r\n    if (changeAddressAssets === toAddress) {\r\n      throw Error(\r\n        \"Wallet.send change address for assets cannot be the same as toAddress \" +\r\n          changeAddressAssets\r\n      );\r\n    }\r\n    const props: ISendInternalProps = {\r\n      fromAddressObjects: this.addressObjects,\r\n      amount,\r\n      assetName,\r\n      baseCurrency: this.baseCurrency,\r\n      changeAddress,\r\n      changeAddressAssets,\r\n      network: this.network,\r\n      rpc: this.rpc,\r\n      toAddress,\r\n    };\r\n    return Transactor.send(props);\r\n  }\r\n\r\n  async getAssets() {\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = (await this.rpc(methods.getaddressbalance, params)) as any;\r\n\r\n    //Remove baseCurrency\r\n    const result = balance.filter((obj) => {\r\n      return obj.assetName !== this.baseCurrency;\r\n    });\r\n    return result;\r\n  }\r\n  async getBalance() {\r\n    const includeAssets = false;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = (await this.rpc(methods.getaddressbalance, params)) as any;\r\n\r\n    return balance.balance / ONE_FULL_COIN;\r\n  }\r\n}\r\n\r\nexport default {\r\n  createInstance,\r\n};\r\nexport async function createInstance(options: IOptions): Promise<Wallet> {\r\n  const wallet = new Wallet();\r\n  await wallet.init(options);\r\n  return wallet;\r\n}\r\n\r\nexport function getBaseCurrencyByNetwork(network: ChainType): string {\r\n  const map = {\r\n    evr: \"EVR\",\r\n    \"evr-test\": \"EVR\",\r\n    rvn: \"RVN\",\r\n    \"rvn-test\": \"RVN\",\r\n  };\r\n  return map[network];\r\n}\r\nexport interface IOptions {\r\n  mnemonic: string;\r\n  minAmountOfAddresses?: number;\r\n  network?: ChainType;\r\n  rpc_username?: string;\r\n  rpc_password?: string;\r\n  rpc_url?: string;\r\n\r\n  offlineMode?: boolean;\r\n}\r\n"],"names":[],"version":3,"file":"types.d.ts.map"}