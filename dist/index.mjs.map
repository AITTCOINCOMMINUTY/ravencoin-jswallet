{"mappings":"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","sources":["src/ravencoinWallet.ts","src/blockchain/sweep.ts","src/blockchain/SendManyTransaction.ts","src/Errors.ts","src/blockchain/Transaction.ts","src/getBaseCurrencyByNetwork.ts","src/getBalance.ts","src/contants.ts","src/getAssets.ts"],"sourcesContent":["import { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\nimport {\n  ChainType,\n  IAddressDelta,\n  IAddressMetaData,\n  IMempoolEntry,\n  IOptions,\n  ISend,\n  ISendManyOptions,\n  ISendResult,\n  IUTXO,\n  SweepResult,\n} from \"./Types\";\n\nimport { sweep } from \"./blockchain/sweep\";\nimport { Transaction } from \"./blockchain/Transaction\";\nimport { SendManyTransaction } from \"./blockchain/SendManyTransaction\";\nimport { getBaseCurrencyByNetwork } from \"./getBaseCurrencyByNetwork\";\nimport { getBalance } from \"./getBalance\";\nimport { ValidationError } from \"./Errors\";\nimport { getAssets } from \"./getAssets\";\n\nexport { Transaction };\nexport { SendManyTransaction };\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\n\n//Avoid singleton (anti-pattern)\n//Meaning multiple instances of the wallet must be able to co-exist\n\nexport class Wallet {\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\n  _mnemonic = \"\";\n  network: ChainType = \"rvn\";\n  addressObjects: Array<IAddressMetaData> = [];\n  receiveAddress = \"\";\n  changeAddress = \"\";\n  addressPosition = 0;\n  baseCurrency = \"RVN\"; //Default is RVN but it could be EVR\n  offlineMode = false;\n  setBaseCurrency(currency: string) {\n    this.baseCurrency = currency;\n  }\n  getBaseCurrency() {\n    return this.baseCurrency;\n  }\n  /**\n   * Sweeping a private key means to send all the funds the address holds to your your wallet.\n   * The private key you sweep does not become a part of your wallet.\n   *\n   * NOTE: the address you sweep needs to cointain enough RVN to pay for the transaction\n   *\n   * @param WIF the private key of the address that you want move funds from\n   * @returns either a string, that is the transaction id or null if there were no funds to send\n   */\n  sweep(WIF: string, onlineMode: boolean): Promise<SweepResult> {\n    const wallet = this;\n\n    return sweep(WIF, wallet, onlineMode);\n  }\n  getAddressObjects() {\n    return this.addressObjects;\n  }\n  getAddresses(): Array<string> {\n    const addresses = this.addressObjects.map((obj) => {\n      return obj.address;\n    });\n    return addresses;\n  }\n\n  async init(options: IOptions) {\n    let username = \"anonymous\";\n    let password = \"anonymous\";\n    let url = URL_MAINNET;\n\n    //VALIDATION\n    if (!options) {\n      throw Error(\"option argument is mandatory\");\n    }\n\n    if (options.offlineMode === true) {\n      this.offlineMode = true;\n    }\n    if (!options.mnemonic) {\n      throw Error(\"option.mnemonic is mandatory\");\n    }\n\n    url = options.rpc_url || url;\n    password = options.rpc_password || url;\n    username = options.rpc_username || url;\n\n    if (options.network) {\n      this.network = options.network;\n      this.setBaseCurrency(getBaseCurrencyByNetwork(options.network));\n    }\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\n      url = URL_TESTNET;\n    }\n\n    this.rpc = getRPC(username, password, url);\n    this._mnemonic = options.mnemonic;\n\n    //Generating the hd key is slow, so we re-use the object\n    const hdKey = RavencoinKey.getHDKey(this.network, this._mnemonic);\n    const coinType = RavencoinKey.getCoinType(this.network);\n    const ACCOUNT = 0;\n\n    const minAmountOfAddresses = Number.isFinite(options.minAmountOfAddresses)\n      ? options.minAmountOfAddresses\n      : 0;\n\n    let doneDerivingAddresses = false;\n    while (doneDerivingAddresses === false) {\n      //We add new addresses to tempAddresses so we can check history for the last 20\n      const tempAddresses = [] as string[];\n\n      for (let i = 0; i < 20; i++) {\n        const external = RavencoinKey.getAddressByPath(\n          this.network,\n          hdKey,\n          `m/44'/${coinType}'/${ACCOUNT}'/0/${this.addressPosition}`\n        );\n\n        const internal = RavencoinKey.getAddressByPath(\n          this.network,\n          hdKey,\n          `m/44'/${coinType}'/${ACCOUNT}'/1/${this.addressPosition}`\n        );\n\n        this.addressObjects.push(external);\n        this.addressObjects.push(internal);\n        this.addressPosition++;\n\n        tempAddresses.push(external.address + \"\");\n        tempAddresses.push(internal.address + \"\");\n      }\n\n      if (\n        minAmountOfAddresses &&\n        minAmountOfAddresses >= this.addressPosition\n      ) {\n        //In case we intend to create extra addresses on startup\n        doneDerivingAddresses = false;\n      } else if (this.offlineMode === true) {\n        //BREAK generation of addresses and do NOT check history on the network\n        doneDerivingAddresses = true;\n      } else {\n        //If no history, break\n        doneDerivingAddresses =\n          false === (await this.hasHistory(tempAddresses));\n      }\n    }\n  }\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\n    const includeAssets = true;\n    const obj = {\n      addresses,\n    };\n\n    const asdf = (await this.rpc(methods.getaddressbalance, [\n      obj,\n      includeAssets,\n    ])) as any;\n\n    //@ts-ignore\n    const hasReceived = Object.values(asdf).find((asset) => asset.received > 0);\n\n    return !!hasReceived;\n  }\n\n  async _getFirstUnusedAddress(external: boolean) {\n    //First, check if lastReceivedAddress\n    if (external === true && this.receiveAddress) {\n      const asdf = await this.hasHistory([this.receiveAddress]);\n      if (asdf === false) {\n        return this.receiveAddress;\n      }\n    }\n    if (external === false && this.changeAddress) {\n      const asdf = await this.hasHistory([this.changeAddress]);\n      if (asdf === false) {\n        return this.changeAddress;\n      }\n    }\n\n    //First make a list of relevant addresses, either external (even) or change (odd)\n    const addresses: string[] = [];\n\n    this.getAddresses().map(function (address: string, index: number) {\n      if (external === true && index % 2 === 0) {\n        addresses.push(address);\n      } else if (external === false && index % 2 !== 0) {\n        addresses.push(address);\n      }\n    });\n\n    //Use BINARY SEARCH\n\n    // Binary search implementation to find the first item with `history` set to false\n    const binarySearch = async (_addresses: string[]) => {\n      let low = 0;\n      let high = _addresses.length - 1;\n      let result = \"\";\n\n      while (low <= high) {\n        const mid = Math.floor((low + high) / 2);\n        const addy = _addresses[mid];\n\n        const hasHistory = await this.hasHistory([addy]);\n        if (hasHistory === false) {\n          result = addy;\n          high = mid - 1; // Continue searching towards the left\n        } else {\n          low = mid + 1; // Continue searching towards the right\n        }\n      }\n\n      return result;\n    };\n\n    const result = await binarySearch(addresses);\n\n    if (!result) {\n      //IF we have not found one, return the first address\n      return addresses[0];\n    }\n    if (external === true) {\n      this.receiveAddress = result;\n    } else {\n      this.changeAddress = result;\n    }\n\n    return result;\n  }\n\n  async getHistory(): Promise<IAddressDelta[]> {\n    const assetName = \"\"; //Must be empty string, NOT \"*\"\n    const addresses = this.getAddresses();\n    const deltas = this.rpc(methods.getaddressdeltas, [\n      { addresses, assetName },\n    ]);\n    //@ts-ignore\n    const addressDeltas: IAddressDelta[] = deltas as IAddressDelta[];\n    return addressDeltas;\n  }\n  async getMempool(): Promise<IMempoolEntry[]> {\n    const method = methods.getaddressmempool;\n    const includeAssets = true;\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\n    return this.rpc(method, params) as Promise<IMempoolEntry[]>;\n  }\n  async getReceiveAddress() {\n    const isExternal = true;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n\n  async getChangeAddress() {\n    const isExternal = false;\n    return this._getFirstUnusedAddress(isExternal);\n  }\n  /**\n   *\n   * @param assetName if present, only return UTXOs for that asset, otherwise for all assets\n   * @returns UTXOs for assets\n   */\n  async getAssetUTXOs(assetName?: string): Promise<IUTXO[]> {\n    //If no asset name, set to wildcard, meaning all assets\n    const _assetName = !assetName ? \"*\" : assetName;\n    const chainInfo = false;\n    const params = [\n      { addresses: this.getAddresses(), chainInfo, assetName: _assetName },\n    ];\n\n    return this.rpc(methods.getaddressutxos, params);\n  }\n  async getUTXOs() {\n    return this.rpc(methods.getaddressutxos, [\n      { addresses: this.getAddresses() },\n    ]);\n  }\n\n  getPrivateKeyByAddress(address: string) {\n    const f = this.addressObjects.find((a) => a.address === address);\n\n    if (!f) {\n      return undefined;\n    }\n    return f.WIF;\n  }\n  async sendRawTransaction(raw: string): Promise<string> {\n    return this.rpc(\"sendrawtransaction\", [raw]);\n  }\n\n  async send(options: ISend): Promise<ISendResult> {\n    //ACTUAL SENDING TRANSACTION\n\n    //Important, do not swallow the exceptions/errors of createTransaction, let them fly\n    const sendResult: ISendResult = await this.createTransaction(options);\n\n    try {\n      const id = await this.rpc(\"sendrawtransaction\", [\n        sendResult.debug.signedTransaction,\n      ]);\n      sendResult.transactionId = id;\n\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n\n  async sendMany({ outputs, assetName }: ISendManyOptions) {\n    const options = {\n      wallet: this,\n      outputs,\n      assetName,\n    };\n    const sendResult: ISendResult = await this.createSendManyTransaction(\n      options\n    );\n\n    //ACTUAL SENDING TRANSACTION\n    //Important, do not swallow the exceptions/errors of createSendManyTransaction, let them fly\n\n    try {\n      const id = await this.rpc(\"sendrawtransaction\", [\n        sendResult.debug.signedTransaction,\n      ]);\n      sendResult.transactionId = id;\n\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n  /**\n   * Does all the heavy lifting regarding creating a SendManyTransaction\n   * but it does not broadcast the actual transaction.\n   * Perhaps the user wants to accept the transaction fee?\n   * @param options\n   * @returns An transaction that has not been broadcasted\n   */\n  async createTransaction(options: ISend): Promise<ISendResult> {\n    const { amount, toAddress } = options;\n    let { assetName } = options;\n\n    if (!assetName) {\n      assetName = this.baseCurrency;\n    }\n\n    //Validation\n    if (!toAddress) {\n      throw Error(\"Wallet.send toAddress is mandatory\");\n    }\n    if (!amount) {\n      throw Error(\"Wallet.send amount is mandatory\");\n    }\n    const changeAddress = await this.getChangeAddress();\n\n    if (changeAddress === toAddress) {\n      throw new Error(\"Change address cannot be the same as toAddress\");\n    }\n    const transaction = new Transaction({\n      assetName,\n      amount,\n      toAddress,\n      wallet: this,\n    });\n\n    await transaction.loadData();\n\n    const inputs = transaction.getInputs();\n    const outputs = await transaction.getOutputs();\n\n    const privateKeys = transaction.getPrivateKeys();\n\n    const raw = await this.rpc(\"createrawtransaction\", [inputs, outputs]);\n    const signed = Signer.sign(\n      this.network,\n      raw,\n      transaction.getUTXOs(),\n      privateKeys\n    );\n\n    //ACTUAL SENDING TRANSACTION\n    try {\n      //   const id = await this.rpc(\"sendrawtransaction\", [signed]);\n      const sendResult: ISendResult = {\n        transactionId: null,\n        debug: {\n          amount,\n          assetName,\n          fee: transaction.getFee(),\n          inputs,\n          outputs,\n          privateKeys,\n          rawUnsignedTransaction: raw,\n          rvnChangeAmount: transaction.getBaseCurrencyChange(),\n          rvnAmount: transaction.getBaseCurrencyAmount(),\n          signedTransaction: signed,\n          UTXOs: transaction.getUTXOs(),\n          walletMempool: transaction.getWalletMempool(),\n        },\n      };\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n\n  /**\n   * Does all the heavy lifting regarding creating a transaction\n   * but it does not broadcast the actual transaction.\n   * Perhaps the user wants to accept the transaction fee?\n   * @param options\n   * @returns An transaction that has not been broadcasted\n   */\n  async createSendManyTransaction(options: {\n    assetName?: string;\n    outputs: { [key: string]: number };\n  }): Promise<ISendResult> {\n    let { assetName } = options;\n\n    if (!assetName) {\n      assetName = this.baseCurrency;\n    }\n\n    //Validation\n    if (!options.outputs) {\n      throw Error(\"Wallet.createSendManyTransaction outputs is mandatory\");\n    } else if (Object.keys(options.outputs).length === 0) {\n      throw new ValidationError(\n        \"outputs is mandatory, shoud be an object with address as keys and amounts (numbers) as values\"\n      );\n    }\n    const changeAddress = await this.getChangeAddress();\n\n    const toAddresses = Object.keys(options.outputs);\n    if (toAddresses.includes(changeAddress)) {\n      throw new Error(\"You cannot send to your current change address\");\n    }\n    const transaction = new SendManyTransaction({\n      assetName,\n      outputs: options.outputs,\n      wallet: this,\n    });\n\n    await transaction.loadData();\n\n    const inputs = transaction.getInputs();\n    const outputs = await transaction.getOutputs();\n\n    const privateKeys = transaction.getPrivateKeys();\n\n    const raw = await this.rpc(\"createrawtransaction\", [inputs, outputs]);\n    const signed = Signer.sign(\n      this.network,\n      raw,\n      transaction.getUTXOs(),\n      privateKeys\n    );\n\n    try {\n      const sendResult: ISendResult = {\n        transactionId: null,\n        debug: {\n          amount: transaction.getAmount(),\n          assetName,\n          fee: transaction.getFee(),\n          inputs,\n          outputs,\n          privateKeys,\n          rawUnsignedTransaction: raw,\n          rvnChangeAmount: transaction.getBaseCurrencyChange(),\n          rvnAmount: transaction.getBaseCurrencyAmount(),\n          signedTransaction: signed,\n          UTXOs: transaction.getUTXOs(),\n          walletMempool: transaction.getWalletMempool(),\n        },\n      };\n      return sendResult;\n    } catch (e) {\n      throw new Error(\n        \"Error while sending, perhaps you have pending transaction? Please try again.\"\n      );\n    }\n  }\n\n  /**\n   * This method checks if an UTXO is being spent in the mempool.\n   * rpc getaddressutxos will list available UTXOs on the chain.\n   * BUT an UTXO can be being spent by a transaction in mempool.\n   *\n   * @param utxo\n   * @returns boolean true if utxo is being spent in mempool, false if not\n   */\n  async isSpentInMempool(utxo: IUTXO) {\n    const mempool = await this.getMempool();\n    for (let entry of mempool) {\n      const sameTxId = entry.txid === utxo.txid;\n      const sameIndex = entry.index === utxo.outputIndex;\n\n      if (sameTxId && sameIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async getAssets() {\n    return getAssets(this, this.getAddresses());\n  }\n  async getBalance() {\n    const a = this.getAddresses();\n    return getBalance(this, a);\n  }\n  async convertMempoolEntryToUTXO(mempoolEntry: IMempoolEntry): Promise<IUTXO> {\n    //Mempool items might not have the script attbribute, we need it\n    const out = await this.rpc(\"gettxout\", [\n      mempoolEntry.txid,\n      mempoolEntry.index,\n      true,\n    ]);\n\n    const utxo = {\n      ...mempoolEntry,\n      script: out.scriptPubKey.hex,\n      outputIndex: mempoolEntry.index,\n      value: mempoolEntry.satoshis / 1e8,\n    };\n    return utxo;\n  }\n\n  /**\n   * Get list of spendable UTXOs in mempool.\n   * Note: a UTXO in mempool can already be \"being spent\"\n   * @param mempool (optional)\n   * @returns list of UTXOs in mempool ready to spend\n   */\n  async getUTXOsInMempool(mempool: IMempoolEntry[]) {\n    //If no mempool argument, fetch mempool\n    let _mempool = mempool;\n    if (!_mempool) {\n      const m = await this.getMempool();\n      _mempool = m;\n    }\n    const mySet = new Set();\n\n    for (let item of _mempool) {\n      if (!item.prevtxid) {\n        continue;\n      }\n      const value = item.prevtxid + \"_\" + item.prevout;\n      mySet.add(value);\n    }\n\n    const spendable = _mempool.filter((item) => {\n      if (item.satoshis < 0) {\n        return false;\n      }\n      const value = item.txid + \"_\" + item.index;\n      return mySet.has(value) === false;\n    });\n\n    const utxos: IUTXO[] = [];\n\n    for (let s of spendable) {\n      const u = await this.convertMempoolEntryToUTXO(s);\n      utxos.push(u);\n    }\n    return utxos;\n  }\n}\n\nexport default {\n  createInstance,\n  getBaseCurrencyByNetwork,\n};\nexport async function createInstance(options: IOptions): Promise<Wallet> {\n  const wallet = new Wallet();\n  await wallet.init(options);\n  return wallet;\n}\n","import RavencoinKey, { Network } from \"@ravenrebels/ravencoin-key\";\nimport Signer from \"@ravenrebels/ravencoin-sign-transaction\";\n\n!!Signer.sign; //\"Idiocracy\" but prevents bundle tools such as PARCEL to strip this dependency out on build.\n\nimport { Wallet } from \"../ravencoinWallet\";\nimport { IInput, SweepResult } from \"../Types\";\nimport { shortenNumber } from \"./SendManyTransaction\";\n\n//sight rate burger maid melody slogan attitude gas account sick awful hammer\n//OH easter egg ;)\nconst WIF = \"Kz5U4Bmhrng4o2ZgwBi5PjtorCeq2dyM7axGQfdxsBSwCKi5ZfTw\";\n\n/**\n *\n * @param WIF the private key in wallet import format that you want to sweep/empty\n * @param wallet your wallet\n * @returns a string of a signed transaction, you have to broad cast it\n */\nexport async function sweep(\n  WIF: string,\n  wallet: Wallet,\n  onlineMode: boolean\n): Promise<SweepResult> {\n  const privateKey = RavencoinKey.getAddressByWIF(wallet.network, WIF);\n\n  const result: SweepResult = {};\n  const rpc = wallet.rpc;\n  const obj = {\n    addresses: [privateKey.address],\n  };\n  const baseCurrencyUTXOs = await rpc(\"getaddressutxos\", [obj]);\n  const obj2 = {\n    addresses: [privateKey.address],\n    assetName: \"*\",\n  };\n\n  const assetUTXOs = await rpc(\"getaddressutxos\", [obj2]);\n  const UTXOs = assetUTXOs.concat(baseCurrencyUTXOs);\n  result.UTXOs = UTXOs;\n  //Create a raw transaction with ALL UTXOs\n\n  if (UTXOs.length === 0) {\n    result.errorDescription = \"Address \" + privateKey.address + \" has no funds\";\n    return result;\n  }\n  const balanceObject = {};\n\n  UTXOs.map((utxo) => {\n    if (!balanceObject[utxo.assetName]) {\n      balanceObject[utxo.assetName] = 0;\n    }\n    balanceObject[utxo.assetName] += utxo.satoshis;\n  });\n\n  const keys = Object.keys(balanceObject);\n\n  //Start simple, get the first addresses from the wallet\n\n  const outputs = {};\n\n  const fixedFee = 0.02; // should do for now\n  keys.map((assetName, index) => {\n    const address = wallet.getAddresses()[index];\n    const amount = balanceObject[assetName] / 1e8;\n\n    if (assetName === wallet.baseCurrency) {\n      outputs[address] = shortenNumber(amount - fixedFee);\n    } else {\n      outputs[address] = {\n        transfer: {\n          [assetName]: amount,\n        },\n      };\n    }\n  });\n  result.outputs = outputs;\n\n  //Convert from UTXO format to INPUT fomat\n  const inputs: Array<IInput> = UTXOs.map((utxo, index) => {\n    /*   {\n         \"txid\":\"id\",                      (string, required) The transaction id\n         \"vout\":n,                         (number, required) The output number\n         \"sequence\":n                      (number, optional) The sequence number\n       } \n       */\n\n    const input: IInput = {\n      txid: utxo.txid,\n      vout: utxo.outputIndex,\n    };\n    return input;\n  });\n  //Create raw transaction\n  const rawHex = await rpc(\"createrawtransaction\", [inputs, outputs]);\n\n  const privateKeys = {\n    [privateKey.address]: WIF,\n  };\n  const signedHex = Signer.sign(wallet.network, rawHex, UTXOs, privateKeys);\n  result.rawTransaction = signedHex;\n  if (onlineMode === true) {\n    result.transactionId = await rpc(\"sendrawtransaction\", [signedHex]);\n  }\n\n  return result;\n}\n","import { InsufficientFundsError, ValidationError } from \"../Errors\";\nimport { Wallet } from \"../ravencoinWallet\";\nimport {\n  IForcedUTXO,\n  IMempoolEntry,\n  ISendManyTransactionOptions,\n  IUTXO,\n} from \"../Types\";\n\nexport class SendManyTransaction {\n  _allUTXOs: IUTXO[]; //all UTXOs that we know of\n\n  private assetName: string;\n  feerate = 1; //When loadData is called, this attribute is updated from the blockchain  wallet = null;\n\n  private wallet: Wallet;\n  private outputs: any;\n  private walletMempool: IMempoolEntry[] = [];\n  private forcedUTXOs: IForcedUTXO[] = [];\n  private forcedChangeAddressAssets: string | undefined = \"\";\n  constructor(options: ISendManyTransactionOptions) {\n    const { wallet, outputs, assetName } = options;\n    this.assetName = !assetName ? wallet.baseCurrency : assetName;\n    this.wallet = wallet;\n    this.outputs = outputs;\n    this.forcedChangeAddressAssets = options.forcedChangeAddressAssets;\n    //Tag forced UTXOs with the \"force\" flag\n    if (options.forcedUTXOs) {\n      options.forcedUTXOs.map((f) => (f.utxo.forced = true));\n      this.forcedUTXOs = options.forcedUTXOs;\n    }\n  }\n\n  getWalletMempool() {\n    return this.walletMempool;\n  }\n  getSizeInKB() {\n    const utxos = this.predictUTXOs();\n    const assumedSizePerUTXO = 300;\n    const assumedSizePerOutput = 100;\n\n    const bytes =\n      (utxos.length + 1) * assumedSizePerUTXO +\n      Object.keys(this.outputs).length * assumedSizePerOutput;\n\n    const kb = bytes / 1024;\n\n    return kb;\n  }\n  async loadData() {\n    //Load blockchain information async, and wait for it\n    const mempoolPromise = this.wallet.getMempool();\n    const assetUTXOsPromise = this.wallet.getAssetUTXOs();\n    const baseCurencyUTXOsPromise = this.wallet.getUTXOs();\n    const feeRatePromise = this.getFeeRate();\n\n    this.walletMempool = await mempoolPromise;\n    const assetUTXOs = await assetUTXOsPromise;\n    const baseCurrencyUTXOs = await baseCurencyUTXOsPromise;\n    this.feerate = await feeRatePromise;\n\n    const mempoolUTXOs = await this.wallet.getUTXOsInMempool(\n      this.walletMempool\n    );\n\n    const _allUTXOsTemp = assetUTXOs\n      .concat(baseCurrencyUTXOs)\n      .concat(mempoolUTXOs);\n\n    //add forced UTXO to the beginning of the array\n    if (this.forcedUTXOs) {\n      for (let f of this.forcedUTXOs) {\n        _allUTXOsTemp.unshift(f.utxo);\n      }\n    }\n    //Filter out UTXOs that are NOT in mempool\n    const allUTXOs = _allUTXOsTemp.filter((utxo) => {\n      const objInMempool = this.walletMempool.find((mempoolEntry) => {\n        if (mempoolEntry.prevtxid) {\n          const result =\n            mempoolEntry.prevtxid === utxo.txid &&\n            mempoolEntry.prevout === utxo.outputIndex;\n\n          return result;\n        }\n        return false;\n      });\n\n      return !objInMempool;\n    });\n\n    //Sort utxos lowest first\n    this._allUTXOs = allUTXOs.sort(sortBySatoshis);\n  }\n  getAmount() {\n    let total = 0;\n\n    const values: number[] = Object.values(this.outputs);\n    values.map((value) => (total += value));\n\n    return total;\n  }\n  getUTXOs(): IUTXO[] {\n    //NOTE, if we have FORCED utxos, they have to be inclued no matter what\n\n    let result: IUTXO[] = [];\n    if (this.isAssetTransfer() === true) {\n      const assetAmount = this.getAmount();\n      const baseCurrencyAmount = this.getBaseCurrencyAmount();\n      const baseCurrencyUTXOs = getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        baseCurrencyAmount\n      );\n      const assetUTXOs = getEnoughUTXOs(\n        this._allUTXOs,\n        this.assetName,\n        assetAmount\n      );\n\n      result = assetUTXOs.concat(baseCurrencyUTXOs);\n    } else {\n      result = getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        this.getBaseCurrencyAmount()\n      );\n    }\n    //Make sure every forced UTXO is part of the list of UTXOs\n\n    for (let forced of this.forcedUTXOs) {\n      const isUTXOBeingUsed = result.find(\n        (utxo) =>\n          utxo.txid === forced.utxo.txid &&\n          utxo.outputIndex === forced.utxo.outputIndex\n      );\n      if (!isUTXOBeingUsed) {\n        result.unshift(forced.utxo);\n      }\n    }\n\n    return result;\n  }\n\n  predictUTXOs() {\n    let utxos: IUTXO[] = [];\n\n    if (this.isAssetTransfer()) {\n      utxos = getEnoughUTXOs(this._allUTXOs, this.assetName, this.getAmount());\n    } else {\n      utxos = getEnoughUTXOs(\n        this._allUTXOs,\n        this.wallet.baseCurrency,\n        this.getAmount()\n      );\n    }\n\n    for (let forced of this.forcedUTXOs) {\n      utxos.push(forced.utxo);\n    }\n    return utxos;\n  }\n  getBaseCurrencyAmount() {\n    const fee = this.getFee();\n\n    if (this.isAssetTransfer() === true) {\n      return fee;\n    } else return this.getAmount() + fee;\n  }\n  getBaseCurrencyChange() {\n    const enoughUTXOs = getEnoughUTXOs(\n      this._allUTXOs,\n      this.wallet.baseCurrency,\n      this.getBaseCurrencyAmount()\n    );\n\n    let total = 0;\n    for (let utxo of enoughUTXOs) {\n      if (utxo.assetName !== this.wallet.baseCurrency) {\n        continue;\n      }\n      total = total + utxo.satoshis / 1e8;\n    }\n    const result = total - this.getBaseCurrencyAmount();\n    return shortenNumber(result);\n  }\n  getAssetChange() {\n    const enoughUTXOs = getEnoughUTXOs(\n      this._allUTXOs,\n      this.assetName,\n      this.getAmount()\n    );\n    let total = 0;\n    for (let utxo of enoughUTXOs) {\n      if (utxo.assetName !== this.assetName) {\n        continue;\n      }\n      total = total + utxo.satoshis / 1e8;\n    }\n    return total - this.getAmount();\n  }\n  isAssetTransfer() {\n    return this.assetName !== this.wallet.baseCurrency;\n  }\n\n  async getOutputs() {\n    //we take the declared outputs and add change outputs\n    const totalOutputs = {};\n\n    if (this.isAssetTransfer() === true) {\n      const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\n\n      //Validate: change address cant be toAddress\n      const toAddresses = Object.keys(this.outputs);\n      if (toAddresses.includes(changeAddressBaseCurrency) === true) {\n        throw new ValidationError(\n          \"Change address cannot be the same as to address\"\n        );\n      }\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\n      const changeAddressAsset = await this._getChangeAddressAssets();\n      //Validate change address can never be the same as toAddress\n      if (toAddresses.includes(changeAddressAsset) === true) {\n        throw new ValidationError(\n          \"Change address cannot be the same as to address\"\n        );\n      }\n      if (this.getAssetChange() > 0) {\n        totalOutputs[changeAddressAsset] = {\n          transfer: {\n            [this.assetName]: this.getAssetChange(),\n          },\n        };\n      }\n\n      for (let addy of Object.keys(this.outputs)) {\n        const amount = this.outputs[addy];\n        totalOutputs[addy] = {\n          transfer: {\n            [this.assetName]: amount,\n          },\n        };\n      }\n    } else {\n      const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\n\n      for (let addy of Object.keys(this.outputs)) {\n        const amount = this.outputs[addy];\n        totalOutputs[addy] = amount;\n      }\n\n      totalOutputs[changeAddressBaseCurrency] = this.getBaseCurrencyChange();\n    }\n    return totalOutputs;\n  }\n\n  async _getChangeAddressAssets() {\n    if (this.forcedChangeAddressAssets) {\n      return this.forcedChangeAddressAssets;\n    }\n    const changeAddressBaseCurrency = await this.wallet.getChangeAddress();\n    const index = this.wallet.getAddresses().indexOf(changeAddressBaseCurrency);\n    const changeAddressAsset = this.wallet.getAddresses()[index + 2];\n    return changeAddressAsset;\n  }\n  getInputs() {\n    return this.getUTXOs().map((obj) => {\n      return { address: obj.address, txid: obj.txid, vout: obj.outputIndex };\n    });\n  }\n\n  getPrivateKeys() {\n    const addressObjects = this.wallet.getAddressObjects();\n    const privateKeys = {};\n    for (let u of this.getUTXOs()) {\n      //Find the address object (we want the WIF) for the address related to the UTXO\n      const addressObject = addressObjects.find(\n        (obj) => obj.address === u.address\n      );\n      if (addressObject) {\n        privateKeys[u.address] = addressObject.WIF;\n      }\n    }\n\n    //Add privatekeys from forcedUTXOs\n    this.forcedUTXOs.map((f) => (privateKeys[f.address] = f.privateKey));\n    return privateKeys;\n  }\n\n  getFee() {\n    const kb = this.getSizeInKB();\n\n    const result = kb * this.feerate;\n\n    return result;\n  }\n  async getFeeRate() {\n    const defaultFee = 0.02;\n    try {\n      const confirmationTarget = 20;\n      const asdf = await this.wallet.rpc(\"estimatesmartfee\", [\n        confirmationTarget,\n      ]);\n      if (!asdf.errors) {\n        return asdf.feerate;\n      } else {\n        return defaultFee;\n      }\n    } catch (e) {\n      //Might occure errors on testnet when calculating fees\n      return defaultFee;\n    }\n  }\n}\n\n//Return the number with max 2 decimals\nexport function shortenNumber(number) {\n  return parseFloat(number.toFixed(2));\n}\n\nfunction sortBySatoshis(u1: IUTXO, u2: IUTXO) {\n  if (u1.satoshis > u2.satoshis) {\n    return 1;\n  }\n  if (u1.satoshis === u2.satoshis) {\n    return 0;\n  }\n  return -1;\n}\n\nfunction getEnoughUTXOs(\n  utxos: IUTXO[],\n  asset: string,\n  amount: number\n): IUTXO[] {\n  const result: IUTXO[] = [];\n  let sum = 0;\n  //First off, add mandatory/forced UTXO, no matter what\n\n  if (!utxos) {\n    throw Error(\"getEnoughUTXOs cannot be called without utxos\");\n  }\n  for (let u of utxos) {\n    if (u.forced === true) {\n      if (u.assetName === asset) {\n        const value = u.satoshis / 1e8;\n        result.push(u);\n        sum = sum + value;\n      }\n    }\n  }\n  for (let u of utxos) {\n    if (sum > amount) {\n      break;\n    }\n    if (u.assetName !== asset) {\n      continue;\n    }\n    //Ignore UTXOs with zero satoshis, seems to occure when assets are minted\n    if (u.satoshis === 0) {\n      continue;\n    }\n    const value = u.satoshis / 1e8;\n    result.push(u);\n    sum = sum + value;\n  }\n\n  if (sum < amount) {\n    const error = new InsufficientFundsError(\n      \"You do not have \" + amount + \" \" + asset + \" you only have \" + sum\n    );\n    throw error;\n  }\n  return result;\n}\n","export class ValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ValidationError\";\n  }\n}\nexport class InvalidAddressError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InvalidAddressError\";\n  }\n}\n\nexport class InsufficientFundsError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InsufficientFundsError\";\n  }\n}\n","import { ISendManyTransactionOptions, ITransactionOptions } from \"../Types\";\nimport { SendManyTransaction } from \"./SendManyTransaction\";\n\nexport class Transaction {\n  private sendManyTransaction: SendManyTransaction;\n\n  constructor({ wallet, toAddress, amount, assetName }: ITransactionOptions) {\n    const options: ISendManyTransactionOptions = {\n      assetName,\n      wallet,\n      outputs: {\n        [toAddress]: amount,\n      },\n    };\n    this.sendManyTransaction = new SendManyTransaction(options);\n  }\n  getWalletMempool() {\n    return this.sendManyTransaction.getWalletMempool();\n  }\n  getSizeInKB() {\n    return this.sendManyTransaction.getSizeInKB();\n  }\n  async loadData() {\n    return this.sendManyTransaction.loadData();\n  }\n  getUTXOs() {\n    return this.sendManyTransaction.getUTXOs();\n  }\n\n  predictUTXOs() {\n    return this.sendManyTransaction.predictUTXOs();\n  }\n  getBaseCurrencyAmount() {\n    return this.sendManyTransaction.getBaseCurrencyAmount();\n  }\n  getBaseCurrencyChange() {\n    return this.sendManyTransaction.getBaseCurrencyChange();\n  }\n  getAssetChange() {\n    return this.sendManyTransaction.getAssetChange();\n  }\n  isAssetTransfer() {\n    return this.sendManyTransaction.isAssetTransfer();\n  }\n\n  async getOutputs() {\n    return this.sendManyTransaction.getOutputs();\n  }\n\n  getInputs() {\n    return this.sendManyTransaction.getInputs();\n  }\n\n  getPrivateKeys() {\n    return this.sendManyTransaction.getPrivateKeys();\n  }\n\n  getFee() {\n    return this.sendManyTransaction.getFee();\n  }\n  async getFeeRate() {\n    return this.sendManyTransaction.getFeeRate();\n  }\n}\n","import { ChainType } from \"./Types\";\n\n\nexport function getBaseCurrencyByNetwork(network: ChainType): string {\n  const map = {\n    evr: \"EVR\",\n    \"evr-test\": \"EVR\",\n    rvn: \"RVN\",\n    \"rvn-test\": \"RVN\",\n  };\n  return map[network];\n}\n","import { methods } from \"@ravenrebels/ravencoin-rpc\";\nimport { ONE_FULL_COIN } from \"./contants\";\nimport { Wallet } from \"./ravencoinWallet\";\n\nexport async function getBalance(wallet:Wallet, addresses: string[]) {\n  const includeAssets = false;\n  const params = [{ addresses }, includeAssets];\n  const balance = (await wallet.rpc(methods.getaddressbalance, params)) as any;\n\n  return balance.balance / ONE_FULL_COIN;\n}\n","export const ONE_FULL_COIN = 1e8;","import { methods } from \"@ravenrebels/ravencoin-rpc\";\nimport { Wallet } from \"./ravencoinWallet\";\n\nexport async function getAssets(wallet:Wallet, addresses: string[]) {\n  const includeAssets = true;\n  const params = [{ addresses: addresses }, includeAssets];\n  const balance = (await wallet.rpc(methods.getaddressbalance, params)) as any;\n\n  //Remove baseCurrency\n  const result = balance.filter((obj) => {\n    return obj.assetName !== wallet.baseCurrency;\n  });\n  return result;\n}\n"],"names":[],"version":3,"file":"index.mjs.map"}