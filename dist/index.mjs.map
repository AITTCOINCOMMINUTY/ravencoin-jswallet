{"mappings":"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","sources":["src/ravencoinWallet.ts","src/contants.ts"],"sourcesContent":["const bitcore = require(\"bitcore-lib\");\r\nconst coininfo = require(\"coininfo\");\r\n\r\nimport { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\r\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\r\nimport { IAddressMetaData } from \"./Types\";\r\nconst { ONE_FULL_COIN } = require(\"./contants\");\r\n\r\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\r\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\r\n\r\n//Avoid singleton (anti-pattern)\r\n//Meaning multiple instances of the wallet must be able to co-exist\r\n\r\nclass Wallet {\r\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\r\n  _mnemonic = \"\";\r\n\r\n  addressObjects: Array<IAddressMetaData> = [];\r\n\r\n  addressPosition = 0;\r\n\r\n  getAddressObjects() {\r\n    return this.addressObjects;\r\n  }\r\n  getAddresses(): Array<string> {\r\n    const addresses = this.addressObjects.map((obj) => {\r\n      return obj.address;\r\n    });\r\n    return addresses;\r\n  }\r\n\r\n  async init(options: IOptions) {\r\n    let username = \"anonymous\";\r\n    let password = \"anonymous\";\r\n    let url = URL_MAINNET;\r\n    //VALIDATION\r\n    if (!options) {\r\n      throw Error(\"option argument is mandatory\");\r\n    }\r\n\r\n    if (!options.mnemonic) {\r\n      throw Error(\"option.mnemonic is mandatory\");\r\n    }\r\n\r\n    url = options.rpc_url || url;\r\n    password = options.rpc_password || url;\r\n    username = options.rpc_username || url;\r\n\r\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\r\n      url = URL_TESTNET;\r\n    }\r\n\r\n    this.rpc = getRPC(username, password, url);\r\n    //DERIVE ADDRESSES BIP44, external 20 unused (that is no history, not no balance)\r\n    //TODO improve performance by creating blocks of 20 addresses and check history for all 20 at once\r\n    //That is one history lookup intead of 20\r\n    this._mnemonic = options.mnemonic;\r\n    let isLast20ExternalAddressesUnused = false;\r\n    const ACCOUNT = 0;\r\n    const network = options.network || \"rvn\";\r\n \r\n    while (isLast20ExternalAddressesUnused === false) {\r\n      const tempAddresses = [] as string[];\r\n\r\n      for (let i = 0; i < 20; i++) {\r\n        const o = RavencoinKey.getAddressPair(\r\n          network,\r\n          this._mnemonic,\r\n          ACCOUNT,\r\n          this.addressPosition\r\n        );\r\n        this.addressObjects.push(o.external);\r\n        this.addressObjects.push(o.internal);\r\n        this.addressPosition++;\r\n\r\n        tempAddresses.push(o.external.address + \"\");\r\n      }\r\n      //If no history, break\r\n      isLast20ExternalAddressesUnused =\r\n        false === (await this.hasHistory(tempAddresses));\r\n    }\r\n  }\r\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\r\n    const includeAssets = true;\r\n    const obj = {\r\n      addresses,\r\n    };\r\n    const asdf = await this.rpc(methods.getaddresstxids, [obj, includeAssets]);\r\n    return asdf.length > 0;\r\n  }\r\n\r\n  async _getFirstUnusedAddress(external: boolean) {\r\n    const addresses = this.getAddresses();\r\n    //even addresses are external, odd address are internal/changes\r\n\r\n    for (let counter = 0; counter < addresses.length; counter++) {\r\n      if (external && counter % 2 !== 0) {\r\n        continue;\r\n      }\r\n      const address = addresses[counter];\r\n\r\n      //If an address has tenth of thousands of transactions, getHistory will throw an exception\r\n\r\n      const asdf = await this.hasHistory([address]);\r\n\r\n      if (asdf === false) {\r\n        return address;\r\n      }\r\n    }\r\n\r\n    //IF we have not found one, return the first address\r\n    return addresses[0];\r\n  }\r\n\r\n  async getReceiveAddress() {\r\n    const isExternal = true;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n\r\n  async getChangeAddress() {\r\n    const isExternal = false;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n  async getUTXOs() {\r\n    return this.rpc(methods.getaddressutxos, [\r\n      { addresses: this.getAddresses() },\r\n    ]);\r\n  }\r\n\r\n  getPrivateKeyByAddress(address: string) {\r\n    const f = this.addressObjects.find((a) => a.address === address);\r\n\r\n    if (!f) {\r\n      return undefined;\r\n    }\r\n    return f.WIF;\r\n  }\r\n\r\n  async send(toAddress: string, amount: number) {\r\n    if (amount < 0) {\r\n      throw Error(\"Amount cannot be negative\");\r\n    }\r\n    if (!toAddress) {\r\n      throw Error(\"toAddress seems invalid\");\r\n    }\r\n    const addresses = this.getAddresses();\r\n    const UTXOs = await this.getUTXOs();\r\n\r\n    //Add Ravencoin as Network to BITCORE\r\n    //@ts-ignore\r\n    const d = coininfo.ravencoin.main.toBitcore();\r\n    d.name = \"ravencoin\";\r\n    d.alias = \"RVN\";\r\n    bitcore.Networks.add(d);\r\n\r\n    //According to the source file bitcore.Networks.get has two arguments, the second argument keys is OPTIONAL\r\n    //The TypescriptTypes says that the second arguments is mandatory, so ignore that\r\n    //@ts-ignore\r\n    const ravencoin = bitcore.Networks.get(\"RVN\");\r\n\r\n    //GET UNSPET OUTPUTS (UTXO)\r\n    //Configure RPC bridge\r\n\r\n    const balance = await this.rpc(methods.getaddressbalance, [\r\n      { addresses: addresses },\r\n    ]);\r\n    if (balance.balance) {\r\n      const b = balance.balance / 1e8;\r\n\r\n      if (b < amount) {\r\n        throw Error(\"Not enough money, \" + b);\r\n      }\r\n    }\r\n\r\n    //GET UNSPENT TRANSACTION OUTPUTS\r\n    const unspent = await this.rpc(methods.getaddressutxos, [\r\n      { addresses: addresses },\r\n    ]);\r\n\r\n    if (unspent.length === 0) {\r\n      throw Error(\"No unspent transactions outputs\");\r\n    }\r\n\r\n    const transaction = new bitcore.Transaction();\r\n    const utxoObjects = UTXOs.map(\r\n      (u) => new bitcore.Transaction.UnspentOutput(u)\r\n    );\r\n\r\n    const privateKeys = utxoObjects.map((utxo) => {\r\n      const addy = utxo.address.toString();\r\n      const key = this.getPrivateKeyByAddress(addy);\r\n      const privateKey = new bitcore.PrivateKey(key);\r\n      return privateKey;\r\n    });\r\n\r\n    transaction.from(utxoObjects);\r\n    transaction.fee(ONE_FULL_COIN * 0.02);\r\n    transaction.to(toAddress, amount * ONE_FULL_COIN);\r\n    transaction.change(addresses[1]); //TODO make dynamic\r\n    transaction.sign(privateKeys);\r\n\r\n    return await this.rpc(methods.sendrawtransaction, [\r\n      transaction.serialize(),\r\n    ]);\r\n  }\r\n  async getAssets() {\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = await this.rpc(methods.getaddressbalance, params);\r\n\r\n    //Remove RVN\r\n    const result = balance.filter((obj) => {\r\n      return obj.assetName !== \"RVN\";\r\n    });\r\n    return result;\r\n  }\r\n  async getBalance() {\r\n    const includeAssets = false;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = await this.rpc(methods.getaddressbalance, params);\r\n\r\n    return balance.balance / ONE_FULL_COIN;\r\n  }\r\n}\r\n\r\nexport default {\r\n  createInstance,\r\n};\r\nexport async function createInstance(options: IOptions) {\r\n  const wallet = new Wallet();\r\n  await wallet.init(options);\r\n  return wallet;\r\n}\r\n\r\nexport interface IOptions {\r\n  rpc_username?: string;\r\n  rpc_password?: string;\r\n  rpc_url?: string;\r\n  mnemonic: string;\r\n  network?: \"rvn\" | \"rvn-test\";\r\n}\r\n","export const ONE_FULL_COIN = 1e8;"],"names":[],"version":3,"file":"index.mjs.map"}