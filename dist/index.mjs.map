{"mappings":"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","sources":["src/ravencoinWallet.ts","src/blockchain/blockchain.ts","src/contants.ts","src/blockchain/Transactor.ts","src/Errors.ts"],"sourcesContent":["const bitcore = require(\"bitcore-lib\");\r\nconst coininfo = require(\"coininfo\");\r\nimport * as blockchain from \"./blockchain/blockchain\";\r\nimport { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\r\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\r\nimport { IAddressDelta, IAddressMetaData, ISend, ISendResult, IUTXO } from \"./Types\";\r\nimport { ONE_FULL_COIN } from \"./contants\";\r\n\r\nimport * as Transactor from \"./blockchain/Transactor\";\r\n\r\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\r\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\r\n\r\n\r\n//Avoid singleton (anti-pattern)\r\n//Meaning multiple instances of the wallet must be able to co-exist\r\n\r\nclass Wallet {\r\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\r\n  _mnemonic = \"\";\r\n  network:\"rvn\" | \"rvn-test\" = \"rvn\";\r\n  addressObjects: Array<IAddressMetaData> = [];\r\n  receiveAddress = \"\";\r\n  addressPosition = 0;\r\n\r\n  getAddressObjects() {\r\n    return this.addressObjects;\r\n  }\r\n  getAddresses(): Array<string> {\r\n    const addresses = this.addressObjects.map((obj) => {\r\n      return obj.address;\r\n    });\r\n    return addresses;\r\n  }\r\n\r\n  async init(options: IOptions) {\r\n    let username = \"anonymous\";\r\n    let password = \"anonymous\";\r\n    let url = URL_MAINNET;\r\n \r\n    //VALIDATION\r\n    if (!options) {\r\n      throw Error(\"option argument is mandatory\");\r\n    }\r\n\r\n    if (!options.mnemonic) {\r\n      throw Error(\"option.mnemonic is mandatory\");\r\n    }\r\n\r\n    url = options.rpc_url || url;\r\n    password = options.rpc_password || url;\r\n    username = options.rpc_username || url;\r\n\r\n    if(options.network){\r\n      this.network = options.network\r\n    }\r\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\r\n      url = URL_TESTNET;\r\n    }\r\n\r\n    this.rpc = getRPC(username, password, url);\r\n    //DERIVE ADDRESSES BIP44, external 20 unused (that is no history, not no balance)\r\n    //TODO improve performance by creating blocks of 20 addresses and check history for all 20 at once\r\n    //That is one history lookup intead of 20\r\n    this._mnemonic = options.mnemonic;\r\n    let isLast20ExternalAddressesUnused = false;\r\n    const ACCOUNT = 0;\r\n    const network = options.network || \"rvn\";\r\n\r\n    while (isLast20ExternalAddressesUnused === false) {\r\n      const tempAddresses = [] as string[];\r\n\r\n      for (let i = 0; i < 20; i++) {\r\n        const o = RavencoinKey.getAddressPair(\r\n          network,\r\n          this._mnemonic,\r\n          ACCOUNT,\r\n          this.addressPosition\r\n        );\r\n        this.addressObjects.push(o.external);\r\n        this.addressObjects.push(o.internal);\r\n        this.addressPosition++;\r\n\r\n        tempAddresses.push(o.external.address + \"\");\r\n      }\r\n      //If no history, break\r\n      isLast20ExternalAddressesUnused =\r\n        false === (await this.hasHistory(tempAddresses));\r\n    }\r\n  }\r\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\r\n    const includeAssets = true;\r\n    const obj = {\r\n      addresses,\r\n    };\r\n    const asdf = await this.rpc(methods.getaddresstxids, [obj, includeAssets]);\r\n    return asdf.length > 0;\r\n  }\r\n\r\n  async _getFirstUnusedAddress(external: boolean) {\r\n    //First, check if lastReveivedAddress\r\n    if (external === true && this.receiveAddress) {\r\n      const asdf = await this.hasHistory([this.receiveAddress]);\r\n      if (asdf === false) {\r\n        console.log(\"Receive address no need to change\");\r\n        return this.receiveAddress;\r\n      }\r\n    }\r\n\r\n    const addresses = this.getAddresses();\r\n    //even addresses are external, odd address are internal/changes\r\n\r\n    for (let counter = 0; counter < addresses.length; counter++) {\r\n      if (external && counter % 2 !== 0) {\r\n        continue;\r\n      }\r\n      const address = addresses[counter];\r\n\r\n      //If an address has tenth of thousands of transactions, getHistory will throw an exception\r\n\r\n      const asdf = await this.hasHistory([address]);\r\n\r\n      if (asdf === false) {\r\n        if (external === true) {\r\n          this.receiveAddress = address;\r\n        }\r\n        return address;\r\n      }\r\n    }\r\n\r\n    //IF we have not found one, return the first address\r\n    return addresses[0];\r\n  }\r\n\r\n  async getMempool(): Promise<IAddressDelta[]> {\r\n    const method = methods.getaddressmempool;\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    return this.rpc(method, params);\r\n  }\r\n  async getReceiveAddress() {\r\n    const isExternal = true;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n\r\n  async getChangeAddress() {\r\n    const isExternal = false;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n  async getUTXOs() {\r\n    return this.rpc(methods.getaddressutxos, [\r\n      { addresses: this.getAddresses() },\r\n    ]);\r\n  }\r\n\r\n  getPrivateKeyByAddress(address: string) {\r\n    const f = this.addressObjects.find((a) => a.address === address);\r\n\r\n    if (!f) {\r\n      return undefined;\r\n    }\r\n    return f.WIF;\r\n  }\r\n\r\n  async send(options: ISend): Promise<ISendResult> {\r\n    const { amount, assetName, toAddress } = options;\r\n\r\n    //Validation\r\n    if (!toAddress) {\r\n      throw Error(\"Wallet.send  toAddress is mandatory\");\r\n    }\r\n    if (!amount) {\r\n      throw Error(\"Wallet.send  amount is mandatory\");\r\n    }\r\n\r\n    if (assetName && assetName !== \"RVN\") {\r\n      return Transactor.send(\r\n        this.rpc,\r\n        this.addressObjects,\r\n        toAddress,\r\n        amount,\r\n        assetName\r\n      );\r\n    } else {\r\n      return this._sendRavencoin(toAddress, amount);\r\n    }\r\n  }\r\n  private async _sendRavencoin(\r\n    toAddress: string,\r\n    amount: number\r\n  ): Promise<ISendResult> {\r\n    if (amount < 0) {\r\n      throw Error(\"Amount cannot be negative\");\r\n    }\r\n    if (!toAddress) {\r\n      throw Error(\"toAddress seems invalid\");\r\n    }\r\n\r\n    const addresses = this.getAddresses();\r\n    const sendResult: ISendResult = {\r\n      transactionId: \"\",\r\n      debug: {},\r\n    };\r\n    //Add Ravencoin as Network to BITCORE\r\n    //@ts-ignore\r\n    const d = coininfo.ravencoin.main.toBitcore();\r\n    d.name = \"ravencoin\";\r\n    d.alias = \"RVN\";\r\n    bitcore.Networks.add(d);\r\n\r\n    //According to the source file bitcore.Networks.get has two arguments, the second argument keys is OPTIONAL\r\n    //The TypescriptTypes says that the second arguments is mandatory, so ignore that\r\n    //@ts-ignore\r\n    const ravencoin = bitcore.Networks.get(\"RVN\");\r\n\r\n    //GET UNSPET OUTPUTS (UTXO)\r\n    //Configure RPC bridge\r\n\r\n    const balance = await this.rpc(methods.getaddressbalance, [\r\n      { addresses: addresses },\r\n    ]);\r\n    if (balance.balance) {\r\n      const b = balance.balance / ONE_FULL_COIN;\r\n\r\n      if (b < amount) {\r\n        throw Error(\"Not enough money, \" + b);\r\n      }\r\n    }\r\n\r\n    //GET UNSPENT TRANSACTION OUTPUTS\r\n    let allUnspent = await this.getUTXOs();\r\n\r\n    const mempool = await blockchain.getMempool(this.rpc);\r\n\r\n    //Filter out UTXOs currently in mempool\r\n    allUnspent = allUnspent.filter(\r\n      (UTXO) => Transactor.isUTXOInMempool(mempool, UTXO) === false\r\n    );\r\n\r\n    //GET ENOUGH UTXOs FOR THIS TRANSACTION\r\n    const unspent = Transactor.getEnoughUTXOs(\r\n      allUnspent,\r\n      amount + 1 /*to cover the fee*/\r\n    );\r\n    if (unspent.length === 0) {\r\n      throw Error(\"No unspent transactions outputs\");\r\n    }\r\n    console.log(\"Will use\", unspent.length, \"UTXO to send\", amount);\r\n    let amo = 0;\r\n    unspent.map((utxo) => (amo += utxo.satoshis / 1e8));\r\n    console.log(\"Amount of UTXO\", amo);\r\n    const transaction = new bitcore.Transaction();\r\n\r\n    const utxoObjects = unspent.map(\r\n      (u) => new bitcore.Transaction.UnspentOutput(u)\r\n    );\r\n\r\n    const changeAddress = await this._getFirstUnusedAddress(false);\r\n\r\n    const privateKeys = utxoObjects.map((utxo) => {\r\n      const addy = utxo.address.toString();\r\n      const key = this.getPrivateKeyByAddress(addy);\r\n      const privateKey = new bitcore.PrivateKey(key);\r\n\r\n      return privateKey;\r\n    });\r\n\r\n    transaction.from(utxoObjects);\r\n    transaction.to(toAddress, amount * ONE_FULL_COIN);\r\n    transaction.change(changeAddress);\r\n\r\n    //UPDATE FEE\r\n    transaction.fee(transaction.getFee() * 100);\r\n    sendResult.debug.fee = transaction.getFee() * 100;\r\n\r\n    console.log(\r\n      \"OK want to send\",\r\n      amount,\r\n      \"has got\",\r\n      amo,\r\n      \"and fee is\",\r\n      transaction.getFee() / 1e8\r\n    );\r\n    transaction.sign(privateKeys);\r\n\r\n    const id = await this.rpc(methods.sendrawtransaction, [\r\n      transaction.serialize(),\r\n    ]);\r\n\r\n    sendResult.transactionId = id;\r\n    return sendResult;\r\n  }\r\n  async getAssets() {\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = await this.rpc(methods.getaddressbalance, params);\r\n\r\n    //Remove RVN\r\n    const result = balance.filter((obj) => {\r\n      return obj.assetName !== \"RVN\";\r\n    });\r\n    return result;\r\n  }\r\n  async getBalance() {\r\n    const includeAssets = false;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = await this.rpc(methods.getaddressbalance, params);\r\n\r\n    return balance.balance / ONE_FULL_COIN;\r\n  }\r\n}\r\n\r\nexport default {\r\n  createInstance,\r\n};\r\nexport async function createInstance(options: IOptions) {\r\n  const wallet = new Wallet();\r\n  await wallet.init(options);\r\n  return wallet;\r\n}\r\n\r\nexport interface IOptions {\r\n  rpc_username?: string;\r\n  rpc_password?: string;\r\n  rpc_url?: string;\r\n  mnemonic: string;\r\n  network?: \"rvn\" | \"rvn-test\";\r\n}\r\n","import {\r\n  IUTXO,\r\n  IValidateAddressResponse,\r\n  IVout,\r\n  IVout_when_creating_transactions,\r\n  RPCType,\r\n} from \"../Types\";\r\nimport { ITransaction } from \"../Types\";\r\n\r\nconst ONE_HUNDRED_MILLION = 1e8;\r\n\r\nexport function getAddressDeltas(rpc: RPCType, addresses: string[]) {\r\n  return rpc(\"getaddressdeltas\", [\r\n    {\r\n      addresses: addresses,\r\n      assetName: \"\",\r\n    },\r\n  ]);\r\n}\r\nexport function sendRawTransaction(rpc: RPCType, signedTransaction: any) {\r\n  const p = rpc(\"sendrawtransaction\", [signedTransaction.hex]);\r\n  p.catch((e: any) => {\r\n    console.log(\"send raw transaction\");\r\n    console.dir(e);\r\n  });\r\n  return p;\r\n}\r\nexport function signRawTransaction(\r\n  rpc: RPCType,\r\n  rawTransactionHex: any,\r\n  privateKeys: Array<string>\r\n) {\r\n  const s = rpc(\"signrawtransaction\", [\r\n    rawTransactionHex,\r\n    null,\r\n    privateKeys,\r\n  ]);\r\n  return s;\r\n}\r\n\r\nexport function decodeRawTransaction(rpc: RPCType, raw: string) {\r\n  return rpc(\"decoderawtransaction\", [raw]);\r\n}\r\n\r\nexport function getRawTransaction(rpc: RPCType, id: string): any {\r\n  return rpc(\"getrawtransaction\", [id, true]);\r\n}\r\nexport function createRawTransaction(\r\n  rpc: RPCType,\r\n  inputs: any,\r\n  outputs: any\r\n): Promise<string> {\r\n  return rpc(\"createrawtransaction\", [inputs, outputs]);\r\n}\r\n\r\nexport async function validateAddress(\r\n  rpc: RPCType,\r\n  address: string\r\n): Promise<IValidateAddressResponse> {\r\n  return rpc(\"validateaddress\", [address]);\r\n}\r\nexport function getBalance(\r\n  rpc: RPCType,\r\n  addresses: Array<string>\r\n): Promise<any> {\r\n  const includeAssets = true;\r\n  const promise = rpc(\"getaddressbalance\", [\r\n    { addresses: addresses },\r\n    includeAssets,\r\n  ]);\r\n  return promise;\r\n}\r\n\r\nexport function _sortUTXOs(list: Array<IUTXO>) {\r\n  //Remember, sort mutates the underlaying array\r\n  //Sort by satoshis, lowest first to prevent dust.\r\n  return list.sort(function (a, b) {\r\n    if (a.satoshis > b.satoshis) {\r\n      return 1;\r\n    }\r\n    if (a.satoshis < b.satoshis) {\r\n      return -1;\r\n    }\r\n    return 0;\r\n  });\r\n}\r\nexport async function getRavenUnspentTransactionOutputs(\r\n  rpc: RPCType,\r\n  addresses: Array<string>\r\n): Promise<Array<IUTXO>> {\r\n  const list: Array<IUTXO> = await rpc(\"getaddressutxos\", [\r\n    { addresses },\r\n  ]);\r\n  _sortUTXOs(list);\r\n  return list;\r\n}\r\nexport function getAssetUnspentTransactionOutputs(\r\n  rpc: RPCType,\r\n  addresses: Array<string>,\r\n  assetName: string\r\n): Promise<Array<IUTXO>> {\r\n  const assets = rpc(\"getaddressutxos\", [{ addresses, assetName }]);\r\n  return assets;\r\n}\r\n\r\nexport function getAllUnspentTransactionOutputs(\r\n  rpc: RPCType,\r\n  addresses: Array<string>\r\n) {\r\n  /*\r\n  Seems like getaddressutxos either return RVN UTXOs or asset UTXOs\r\n  Never both.\r\n  So we make two requests and we join the answer\r\n  */\r\n  const raven = rpc(\"getaddressutxos\", [{ addresses }]);\r\n  const assets = rpc(\"getaddressutxos\", [{ addresses, assetName: \"*\" }]);\r\n\r\n  return Promise.all([raven, assets]).then((values: Array<any>) => {\r\n    const all = values[0].concat(values[1]);\r\n    return all;\r\n  });\r\n}\r\nexport async function getMempool(rpc: RPCType): Promise<Array<ITransaction>> {\r\n  const ids = await rpc(\"getrawmempool\", []);\r\n\r\n  const result: any = [];\r\n  for (const id of ids) {\r\n    const transaction = await getRawTransaction(rpc, id);\r\n    result.push(transaction);\r\n  }\r\n  return result;\r\n}\r\nexport function convertUTXOsToVOUT(\r\n  UTXOs: Array<IUTXO>\r\n): Array<IVout_when_creating_transactions> {\r\n  const inputs = UTXOs.map(function (bla) {\r\n    //OK we have to convert from \"unspent\" format to \"vout\"\r\n\r\n    const obj = {\r\n      txid: bla.txid,\r\n      vout: bla.outputIndex,\r\n      address: bla.address,\r\n    };\r\n    return obj;\r\n  });\r\n  return inputs;\r\n}\r\n","export const ONE_FULL_COIN = 1e8;","import {\r\n  IAddressMetaData,\r\n  ISendResult,\r\n  IUTXO,\r\n  IVout,\r\n  IVout_when_creating_transactions,\r\n  RPCType,\r\n} from \"../Types\";\r\nimport * as blockchain from \"./blockchain\";\r\n\r\nimport { ITransaction } from \"../Types\";\r\nimport { ONE_FULL_COIN } from \"../contants\";\r\nimport { InsufficientFundsError, InvalidAddressError, ValidationError } from \"../Errors\";\r\n\r\ninterface IInternalSendIProp {\r\n  fromAddressObjects: Array<IAddressMetaData>;\r\n  amount: number;\r\n  assetName: string;\r\n  toAddress: string;\r\n  rpc: RPCType;\r\n}\r\n\r\nasync function isValidAddress(rpc: RPCType, address: string) {\r\n  const obj = await blockchain.validateAddress(rpc, address);\r\n  return obj.isvalid === true;\r\n}\r\n\r\nfunction sumOfUTXOs(UTXOs: Array<IUTXO>) {\r\n  let unspentRavencoinAmount = 0;\r\n  UTXOs.map(function (item) {\r\n    const newValue = item.satoshis / 1e8;\r\n    unspentRavencoinAmount = unspentRavencoinAmount + newValue;\r\n  });\r\n  return unspentRavencoinAmount;\r\n}\r\n/*\r\n\r\n    \"Chicken and egg\" situation.\r\n    We need to calculate how much we shall pay in fees based on the size of the transaction.\r\n    When adding inputs/outputs for the fee, we increase the fee.\r\n\r\n    Lets start by first assuming that we will pay 1 RVN in fee (that is sky high).\r\n    Than we check the size of the transaction and then we just adjust the change output so the fee normalizes\r\n*/\r\nasync function getFee(\r\n  rpc: RPCType,\r\n  inputs: Array<IVout_when_creating_transactions>,\r\n  outputs: Array<IVout>\r\n): Promise<number> {\r\n  const ONE_KILOBYTE = 1024;\r\n  //Create a raw transaction to get an aproximation for transaction size.\r\n  const raw = await blockchain.createRawTransaction(rpc, inputs, outputs);\r\n\r\n  //Get the length of the string bytes not the string\r\n  //This is NOT the exact size since we will add an output for the change address to the transaction\r\n  //Perhaps we should calculate size plus 10%?\r\n  const size = Buffer.from(raw).length / ONE_KILOBYTE;\r\n  console.log(\"Size of raw transaction\", size);\r\n  let fee = 0.02;\r\n  //TODO should ask the \"blockchain\" **estimatesmartfee**\r\n\r\n  return fee * Math.max(1, size);\r\n}\r\n\r\nasync function _send(options: IInternalSendIProp): Promise<ISendResult> {\r\n  const { amount, assetName, fromAddressObjects, toAddress, rpc } = options;\r\n\r\n  const sendResult: ISendResult = {\r\n    transactionId: \"undefined\",\r\n    debug: {},\r\n  };\r\n  const MAX_FEE = 4;\r\n\r\n  const isAssetTransfer = assetName !== \"RVN\";\r\n\r\n  //VALIDATION\r\n  if ((await isValidAddress(rpc, toAddress)) === false) {\r\n    throw new InvalidAddressError(\"Invalid address \" + toAddress);\r\n  }\r\n  if (amount < 0) {\r\n    throw new ValidationError(\"Cant send less than zero\");\r\n  }\r\n\r\n  const addresses = fromAddressObjects.map((a) => a.address);\r\n\r\n  //Do we have enough of the asset?\r\n  if(isAssetTransfer === true){\r\n    const b = await blockchain.getBalance(rpc, addresses);\r\n    const a = b.find(asset => asset.assetName === assetName);\r\n    if(!a){        \r\n      throw new InsufficientFundsError(\"You do not have any \" + assetName);\r\n    }\r\n    const balance = a.balance /ONE_FULL_COIN;\r\n    if(balance < amount){ \r\n      throw new InsufficientFundsError(\"You do not have \" + amount + \" \" + assetName);\r\n    }\r\n\r\n}\r\n\r\n  //TODO change addresses should be checked with the blockchain,\r\n  //find first unused change address\r\n  const ravencoinChangeAddress = addresses[1];\r\n  const assetChangeAddress = addresses[3];\r\n\r\n  let UTXOs = await blockchain.getRavenUnspentTransactionOutputs(\r\n    rpc,\r\n    addresses\r\n  );\r\n\r\n  //Remove UTXOs that are currently in mempool\r\n  const mempool = await blockchain.getMempool(rpc);\r\n\r\n  UTXOs = UTXOs.filter((UTXO) => isUTXOInMempool(mempool, UTXO) === false);\r\n\r\n  const enoughRavencoinUTXOs = getEnoughUTXOs(\r\n    UTXOs,\r\n    isAssetTransfer ? 1 : amount + MAX_FEE\r\n  );\r\n\r\n  //Sum up the whole unspent amount\r\n  let unspentRavencoinAmount = sumOfUTXOs(enoughRavencoinUTXOs);\r\n  if (unspentRavencoinAmount <= 0) {\r\n    throw new InsufficientFundsError(\r\n      \"Not enough RVN to transfer asset, perhaps your wallet has pending transactions\"\r\n    );\r\n  }\r\n  sendResult.debug.unspentRVNAmount = unspentRavencoinAmount.toLocaleString();\r\n\r\n  if (isAssetTransfer === false) {\r\n    if (amount > unspentRavencoinAmount) {\r\n      throw new InsufficientFundsError(\r\n        \"Insufficient funds, cant send \" +\r\n          amount.toLocaleString() +\r\n          \" only have \" +\r\n          unspentRavencoinAmount.toLocaleString()\r\n      );\r\n    }\r\n  }\r\n\r\n  const rvnAmount = isAssetTransfer ? 0 : amount;\r\n  sendResult.debug.rvnUTXOs = enoughRavencoinUTXOs;\r\n  const inputs = blockchain.convertUTXOsToVOUT(enoughRavencoinUTXOs);\r\n  const outputs: any = {};\r\n  //Add asset inputs\r\n  if (isAssetTransfer === true) {\r\n   const assetUTXOs =  await addAssetInputsAndOutputs(\r\n      rpc,\r\n      addresses,\r\n      assetName,\r\n      amount,\r\n      inputs,\r\n      outputs,\r\n      toAddress,\r\n      assetChangeAddress\r\n    );\r\n    sendResult.debug.assetUTXOs = assetUTXOs;\r\n  } else if (isAssetTransfer === false) {\r\n    outputs[toAddress] = rvnAmount;\r\n  }\r\n\r\n  const fee = await getFee(rpc, inputs, outputs);\r\n  sendResult.debug.assetName = assetName;\r\n  sendResult.debug.fee = fee;\r\n  sendResult.debug.rvnAmount = 0;\r\n\r\n  const ravencoinChangeAmount = unspentRavencoinAmount - rvnAmount - fee;\r\n\r\n  sendResult.debug.rvnChangeAmount = ravencoinChangeAmount;\r\n\r\n  //Obviously we only add change address if there is any change\r\n  if (getTwoDecimalTrunc(ravencoinChangeAmount) > 0) {\r\n    outputs[ravencoinChangeAddress] = getTwoDecimalTrunc(ravencoinChangeAmount);\r\n  }\r\n  //Now we have enough UTXos, lets create a raw transactions\r\n\r\n  const raw = await blockchain.createRawTransaction(rpc, inputs, outputs);\r\n  sendResult.debug.inputs = inputs;\r\n  sendResult.debug.rawUnsignedTransaction = raw;\r\n  //OK lets find the private keys (WIF) for input addresses\r\n  type TPrivateKey = {\r\n    [key: string]: string;\r\n  };\r\n  const privateKeys: TPrivateKey = {};\r\n  inputs.map(function (input: IVout_when_creating_transactions) {\r\n    const addy = input.address;\r\n    const addressObject = fromAddressObjects.find((a) => a.address === addy);\r\n    if (addressObject) {\r\n      privateKeys[addy] = addressObject.WIF;\r\n    }\r\n  });\r\n  sendResult.debug.privateKeys = privateKeys;\r\n  //Sign the transaction\r\n  const keys: Array<string> = Object.values(privateKeys);\r\n  const signedTransactionPromise = blockchain.signRawTransaction(\r\n    rpc,\r\n    raw,\r\n    keys\r\n  );\r\n  signedTransactionPromise.catch((e: any) => {\r\n    console.dir(e);\r\n  });\r\n\r\n  const signedTransaction = await signedTransactionPromise;\r\n  sendResult.debug.signedTransaction = signedTransaction;\r\n  const txid = await blockchain.sendRawTransaction(rpc, signedTransaction);\r\n  sendResult.transactionId = txid;\r\n  return sendResult;\r\n}\r\n\r\nasync function addAssetInputsAndOutputs(\r\n  rpc: RPCType,\r\n  addresses: string[],\r\n  assetName: string,\r\n  amount: number,\r\n  inputs: IVout_when_creating_transactions[],\r\n  outputs: any,\r\n  toAddress: string,\r\n  assetChangeAddress: string\r\n) {\r\n  let assetUTXOs = await blockchain.getAssetUnspentTransactionOutputs(\r\n    rpc,\r\n    addresses,\r\n    assetName\r\n  );\r\n\r\n  const mempool = await blockchain.getMempool(rpc);\r\n  assetUTXOs = assetUTXOs.filter(\r\n    (UTXO) => isUTXOInMempool(mempool, UTXO) === false\r\n  );\r\n\r\n  const _UTXOs = getEnoughUTXOs(assetUTXOs, amount);\r\n  const tempInputs = blockchain.convertUTXOsToVOUT(_UTXOs);\r\n  tempInputs.map((item) => inputs.push(item));\r\n\r\n  outputs[toAddress] = {\r\n    transfer: {\r\n      [assetName]: amount,\r\n    },\r\n  };\r\n\r\n  const assetSum = sumOfUTXOs(_UTXOs);\r\n\r\n  //Only add change address if needed\r\n  if (assetSum - amount > 0) {\r\n    outputs[assetChangeAddress] = {\r\n      transfer: {\r\n        [assetName]: assetSum - amount,\r\n      },\r\n    };\r\n  }\r\n\r\n  return _UTXOs;//Return the UTXOs used for asset transfer\r\n}\r\n\r\nfunction getTwoDecimalTrunc(num: number) {\r\n  //Found answer here https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary\r\n  //In JavaScript the number 77866.98 minus 111 minus 0.2 equals 77755.95999999999\r\n  //We want it to be 77755.96\r\n  return Math.trunc(num * 100) / 100;\r\n}\r\n\r\nexport async function send(\r\n  rpc: RPCType,\r\n  fromAddressObjects: Array<IAddressMetaData>,\r\n  toAddress: string,\r\n  amount: number,\r\n  assetName: string\r\n) {\r\n  return _send({ rpc, fromAddressObjects, toAddress, amount, assetName });\r\n}\r\n\r\nexport function getEnoughUTXOs(\r\n  utxos: Array<IUTXO>,\r\n  amount: number\r\n): Array<IUTXO> {\r\n  /*\r\n  Scenario ONE\r\n  Bob has 300 UTXO with 1 RVN each.\r\n  Bob has one UTXO with 400 RVN.\r\n\r\n  Bob intends to send 300 RVN\r\n  In this case the best thing to do is to use the single 400 UTXO\r\n\r\n  SCENARIO TWO\r\n\r\n  Alice have tons of small UTXOs like 0.03 RVN, 0.2 RVN, she wants to send 5 RVN.\r\n  In this case it makes sense to clean up the \"dust\", so you dont end up with a lot of small change.\r\n\r\n\r\n  */\r\n\r\n  //For small transactions,start with small transactions first.\r\n  let tempAmount = 0;\r\n\r\n  const returnValue: Array<IUTXO> = [];\r\n\r\n  utxos.map(function (utxo) {\r\n    if (utxo.satoshis !== 0 && tempAmount < amount) {\r\n      const value = utxo.satoshis / ONE_FULL_COIN;\r\n      tempAmount = tempAmount + value;\r\n      returnValue.push(utxo);\r\n    }\r\n  });\r\n\r\n  //Did we use a MASSIVE amount of UTXOs to safisfy this transaction?\r\n  //In this case check if we do have one single UTXO that can satisfy our needs\r\n  if (returnValue.length > 10) {\r\n    const largerUTXO = utxos.find(\r\n      (utxo) => utxo.satoshis / ONE_FULL_COIN > amount\r\n    );\r\n\r\n    if (largerUTXO) {\r\n      //Send this one UTXO that covers it all\r\n      return [largerUTXO];\r\n    }\r\n  }\r\n  return returnValue;\r\n}\r\n\r\nexport function isUTXOInMempool(\r\n  mempool: Array<ITransaction>,\r\n  UTXO: IUTXO\r\n): boolean {\r\n  function format(transactionId: string, index: number) {\r\n    return transactionId + \"_\" + index;\r\n  }\r\n\r\n  const listOfUTXOsInMempool: Array<string> = [];\r\n  mempool.map((transaction) => {\r\n    transaction.vin.map((vin) => {\r\n      const id = format(vin.txid, vin.vout);\r\n      listOfUTXOsInMempool.push(id);\r\n    });\r\n  });\r\n\r\n  const index = listOfUTXOsInMempool.indexOf(\r\n    format(UTXO.txid, UTXO.outputIndex)\r\n  );\r\n  const isInMempool = index > -1;\r\n\r\n  return isInMempool;\r\n}\r\n","export class ValidationError extends Error {\r\n  constructor(message:string) {\r\n    super(message); // (1)\r\n    this.name = \"ValidationError\"; // (2)\r\n  }\r\n}\r\nexport class InvalidAddressError  extends Error {\r\n  constructor(message:string) {\r\n    super(message); // (1)\r\n    this.name = \"InvalidAddressError\"; // (2)\r\n  }\r\n}\r\n\r\n\r\n  export class InsufficientFundsError extends Error {\r\n    constructor(message:string) {\r\n      super(message); // (1)\r\n      this.name = \"InsufficientFundsError\"; // (2)\r\n    }\r\n  }\r\n\r\n  "],"names":[],"version":3,"file":"index.mjs.map"}