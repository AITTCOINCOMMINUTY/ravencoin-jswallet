{"mappings":"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","sources":["src/ravencoinWallet.ts","src/contants.ts","src/blockchain/Transactor.ts","src/blockchain/blockchain.ts"],"sourcesContent":["const bitcore = require(\"bitcore-lib\");\r\nconst coininfo = require(\"coininfo\");\r\n\r\nimport { getRPC, methods } from \"@ravenrebels/ravencoin-rpc\";\r\nimport RavencoinKey from \"@ravenrebels/ravencoin-key\";\r\nimport { IAddressMetaData, IUTXO } from \"./Types\";\r\nimport { ONE_FULL_COIN } from \"./contants\";\r\n\r\nimport * as Transactor from \"./blockchain/Transactor\";\r\n\r\nconst URL_MAINNET = \"https://rvn-rpc-mainnet.ting.finance/rpc\";\r\nconst URL_TESTNET = \"https://rvn-rpc-testnet.ting.finance/rpc\";\r\n\r\ninterface ISend {\r\n  assetName?: string;\r\n  toAddress: string;\r\n  amount: number;\r\n}\r\n\r\n//Avoid singleton (anti-pattern)\r\n//Meaning multiple instances of the wallet must be able to co-exist\r\n\r\nclass Wallet {\r\n  rpc = getRPC(\"anonymous\", \"anonymous\", URL_MAINNET);\r\n  _mnemonic = \"\";\r\n\r\n  addressObjects: Array<IAddressMetaData> = [];\r\n\r\n  addressPosition = 0;\r\n\r\n  getAddressObjects() {\r\n    return this.addressObjects;\r\n  }\r\n  getAddresses(): Array<string> {\r\n    const addresses = this.addressObjects.map((obj) => {\r\n      return obj.address;\r\n    });\r\n    return addresses;\r\n  }\r\n\r\n  async init(options: IOptions) {\r\n    let username = \"anonymous\";\r\n    let password = \"anonymous\";\r\n    let url = URL_MAINNET;\r\n    //VALIDATION\r\n    if (!options) {\r\n      throw Error(\"option argument is mandatory\");\r\n    }\r\n\r\n    if (!options.mnemonic) {\r\n      throw Error(\"option.mnemonic is mandatory\");\r\n    }\r\n\r\n    url = options.rpc_url || url;\r\n    password = options.rpc_password || url;\r\n    username = options.rpc_username || url;\r\n\r\n    if (options.network === \"rvn-test\" && !options.rpc_url) {\r\n      url = URL_TESTNET;\r\n    }\r\n\r\n    this.rpc = getRPC(username, password, url);\r\n    //DERIVE ADDRESSES BIP44, external 20 unused (that is no history, not no balance)\r\n    //TODO improve performance by creating blocks of 20 addresses and check history for all 20 at once\r\n    //That is one history lookup intead of 20\r\n    this._mnemonic = options.mnemonic;\r\n    let isLast20ExternalAddressesUnused = false;\r\n    const ACCOUNT = 0;\r\n    const network = options.network || \"rvn\";\r\n\r\n    while (isLast20ExternalAddressesUnused === false) {\r\n      const tempAddresses = [] as string[];\r\n\r\n      for (let i = 0; i < 20; i++) {\r\n        const o = RavencoinKey.getAddressPair(\r\n          network,\r\n          this._mnemonic,\r\n          ACCOUNT,\r\n          this.addressPosition\r\n        );\r\n        this.addressObjects.push(o.external);\r\n        this.addressObjects.push(o.internal);\r\n        this.addressPosition++;\r\n\r\n        tempAddresses.push(o.external.address + \"\");\r\n      }\r\n      //If no history, break\r\n      isLast20ExternalAddressesUnused =\r\n        false === (await this.hasHistory(tempAddresses));\r\n    }\r\n  }\r\n  async hasHistory(addresses: Array<string>): Promise<boolean> {\r\n    const includeAssets = true;\r\n    const obj = {\r\n      addresses,\r\n    };\r\n    const asdf = await this.rpc(methods.getaddresstxids, [obj, includeAssets]);\r\n    return asdf.length > 0;\r\n  }\r\n\r\n  async _getFirstUnusedAddress(external: boolean) {\r\n    const addresses = this.getAddresses();\r\n    //even addresses are external, odd address are internal/changes\r\n\r\n    for (let counter = 0; counter < addresses.length; counter++) {\r\n      if (external && counter % 2 !== 0) {\r\n        continue;\r\n      }\r\n      const address = addresses[counter];\r\n\r\n      //If an address has tenth of thousands of transactions, getHistory will throw an exception\r\n\r\n      const asdf = await this.hasHistory([address]);\r\n\r\n      if (asdf === false) {\r\n        return address;\r\n      }\r\n    }\r\n\r\n    //IF we have not found one, return the first address\r\n    return addresses[0];\r\n  }\r\n\r\n  async getReceiveAddress() {\r\n    const isExternal = true;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n\r\n  async getChangeAddress() {\r\n    const isExternal = false;\r\n    return this._getFirstUnusedAddress(isExternal);\r\n  }\r\n  async getUTXOs() {\r\n    return this.rpc(methods.getaddressutxos, [\r\n      { addresses: this.getAddresses() },\r\n    ]);\r\n  }\r\n\r\n  getPrivateKeyByAddress(address: string) {\r\n    const f = this.addressObjects.find((a) => a.address === address);\r\n\r\n    if (!f) {\r\n      return undefined;\r\n    }\r\n    return f.WIF;\r\n  }\r\n\r\n  async send(options: ISend) {\r\n    const { amount, assetName, toAddress } = options;\r\n    if (assetName && assetName !== \"RVN\") {\r\n      return Transactor.send(\r\n        this.rpc,\r\n        this.addressObjects,\r\n        toAddress,\r\n        amount,\r\n        assetName\r\n      );\r\n    } else {\r\n      return this._sendRavencoin(toAddress, amount);\r\n    }\r\n  }\r\n  private async _sendRavencoin(toAddress: string, amount: number) {\r\n    if (amount < 0) {\r\n      throw Error(\"Amount cannot be negative\");\r\n    }\r\n    if (!toAddress) {\r\n      throw Error(\"toAddress seems invalid\");\r\n    }\r\n    console.log(\"Should send\", amount, \"to\", toAddress);\r\n    const addresses = this.getAddresses();\r\n    const UTXOs = await this.getUTXOs();\r\n\r\n    //Add Ravencoin as Network to BITCORE\r\n    //@ts-ignore\r\n    const d = coininfo.ravencoin.main.toBitcore();\r\n    d.name = \"ravencoin\";\r\n    d.alias = \"RVN\";\r\n    bitcore.Networks.add(d);\r\n\r\n    //According to the source file bitcore.Networks.get has two arguments, the second argument keys is OPTIONAL\r\n    //The TypescriptTypes says that the second arguments is mandatory, so ignore that\r\n    //@ts-ignore\r\n    const ravencoin = bitcore.Networks.get(\"RVN\");\r\n\r\n    //GET UNSPET OUTPUTS (UTXO)\r\n    //Configure RPC bridge\r\n\r\n    const balance = await this.rpc(methods.getaddressbalance, [\r\n      { addresses: addresses },\r\n    ]);\r\n    if (balance.balance) {\r\n      const b = balance.balance / 1e8;\r\n\r\n      if (b < amount) {\r\n        throw Error(\"Not enough money, \" + b);\r\n      }\r\n    }\r\n\r\n    //GET UNSPENT TRANSACTION OUTPUTS\r\n    const allUnspent = await this.rpc(methods.getaddressutxos, [\r\n      { addresses: addresses },\r\n    ]);\r\n\r\n    //GET ENOUGH UTXOs FOR THIS TRANSACTION\r\n    const unspent = getEnoughUTXOs(allUnspent, amount);\r\n    if (unspent.length === 0) {\r\n      throw Error(\"No unspent transactions outputs\");\r\n    }\r\n\r\n    const transaction = new bitcore.Transaction();\r\n    const utxoObjects = unspent.map(\r\n      (u) => new bitcore.Transaction.UnspentOutput(u)\r\n    );\r\n\r\n    const changeAddress = await this._getFirstUnusedAddress(false);\r\n\r\n    const privateKeys = utxoObjects.map((utxo) => {\r\n      const addy = utxo.address.toString();\r\n      const key = this.getPrivateKeyByAddress(addy);\r\n      const privateKey = new bitcore.PrivateKey(key);\r\n      return privateKey;\r\n    });\r\n\r\n    transaction.from(utxoObjects);\r\n    transaction.fee(ONE_FULL_COIN * 0.02);\r\n    transaction.to(toAddress, amount * ONE_FULL_COIN);\r\n    transaction.change(changeAddress); //TODO make dynamic\r\n    transaction.sign(privateKeys);\r\n\r\n    return await this.rpc(methods.sendrawtransaction, [\r\n      transaction.serialize(),\r\n    ]);\r\n  }\r\n  async getAssets() {\r\n    const includeAssets = true;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = await this.rpc(methods.getaddressbalance, params);\r\n\r\n    //Remove RVN\r\n    const result = balance.filter((obj) => {\r\n      return obj.assetName !== \"RVN\";\r\n    });\r\n    return result;\r\n  }\r\n  async getBalance() {\r\n    const includeAssets = false;\r\n    const params = [{ addresses: this.getAddresses() }, includeAssets];\r\n    const balance = await this.rpc(methods.getaddressbalance, params);\r\n\r\n    return balance.balance / ONE_FULL_COIN;\r\n  }\r\n}\r\n\r\nexport default {\r\n  createInstance,\r\n};\r\nexport async function createInstance(options: IOptions) {\r\n  const wallet = new Wallet();\r\n  await wallet.init(options);\r\n  return wallet;\r\n}\r\n\r\nexport interface IOptions {\r\n  rpc_username?: string;\r\n  rpc_password?: string;\r\n  rpc_url?: string;\r\n  mnemonic: string;\r\n  network?: \"rvn\" | \"rvn-test\";\r\n}\r\n\r\nexport function getEnoughUTXOs(\r\n  utxos: Array<IUTXO>,\r\n  amount: number\r\n): Array<IUTXO> {\r\n  let tempAmount = 0;\r\n  const returnValue: Array<IUTXO> = [];\r\n\r\n  utxos.map(function (utxo) {\r\n    if (utxo.satoshis !== 0 && tempAmount < amount) {\r\n      const value = utxo.satoshis / 1e8;\r\n      tempAmount = tempAmount + value;\r\n      returnValue.push(utxo);\r\n    }\r\n  });\r\n  return returnValue;\r\n}\r\n","export const ONE_FULL_COIN = 1e8;","import {\r\n  IAddressMetaData,\r\n  IUTXO,\r\n  IVout,\r\n  IVout_when_creating_transactions,\r\n  RPCType,\r\n} from \"../Types\";\r\nimport * as blockchain from \"./blockchain\";\r\n\r\nimport { ITransaction } from \"../Types\";\r\n\r\ninterface IInternalSendIProp {\r\n  fromAddressObjects: Array<IAddressMetaData>;\r\n  amount: number;\r\n  assetName: string;\r\n  toAddress: string;\r\n  rpc: RPCType;\r\n}\r\n\r\nasync function isValidAddress(rpc: RPCType, address: string) {\r\n  const obj = await blockchain.validateAddress(rpc, address);\r\n  return obj.isvalid === true;\r\n}\r\n\r\nfunction sumOfUTXOs(UTXOs: Array<IUTXO>) {\r\n  let unspentRavencoinAmount = 0;\r\n  UTXOs.map(function (item) {\r\n    const newValue = item.satoshis / 1e8;\r\n    unspentRavencoinAmount = unspentRavencoinAmount + newValue;\r\n  });\r\n  return unspentRavencoinAmount;\r\n}\r\n/*\r\n\r\n    \"Chicken and egg\" situation.\r\n    We need to calculate how much we shall pay in fees based on the size of the transaction.\r\n    When adding inputs/outputs for the fee, we increase the fee.\r\n\r\n    Lets start by first assuming that we will pay 1 RVN in fee (that is sky high).\r\n    Than we check the size of the transaction and then we just adjust the change output so the fee normalizes\r\n*/\r\nasync function getFee(\r\n  rpc: RPCType,\r\n  inputs: Array<IVout_when_creating_transactions>,\r\n  outputs: Array<IVout>\r\n): Promise<number> {\r\n  const ONE_KILOBYTE = 1024;\r\n  //Create a raw transaction to get an aproximation for transaction size.\r\n  const raw = await blockchain.createRawTransaction(rpc, inputs, outputs);\r\n\r\n  //Get the length of the string bytes not the string\r\n  //This is NOT the exact size since we will add an output for the change address to the transaction\r\n  //Perhaps we should calculate size plus 10%?\r\n  const size = Buffer.from(raw).length / ONE_KILOBYTE;\r\n  console.log(\"Size of raw transaction\", size);\r\n  let fee = 0.02;\r\n  //TODO should ask the \"blockchain\" **estimatesmartfee**\r\n\r\n  return fee * Math.max(1, size);\r\n}\r\n\r\nasync function _send(options: IInternalSendIProp): Promise<string> {\r\n  const { amount, assetName, fromAddressObjects, toAddress, rpc } = options;\r\n\r\n  const MAX_FEE = 4;\r\n\r\n  const isAssetTransfer = assetName !== \"RVN\";\r\n\r\n  //VALIDATION\r\n  if ((await isValidAddress(rpc, toAddress)) === false) {\r\n    throw Error(\"Invalid address \" + toAddress);\r\n  }\r\n  if (amount < 0) {\r\n    throw Error(\"Cant send less than zero\");\r\n  }\r\n\r\n  const addresses = fromAddressObjects.map((a) => a.address);\r\n\r\n  //TODO change addresses should be checked with the blockchain,\r\n  //find first unused change address\r\n  const ravencoinChangeAddress = addresses[1];\r\n  const assetChangeAddress = addresses[3];\r\n\r\n  let UTXOs = await blockchain.getRavenUnspentTransactionOutputs(\r\n    rpc,\r\n    addresses\r\n  );\r\n\r\n  //Remove UTXOs that are currently in mempool\r\n  const mempool = await blockchain.getMempool(rpc);\r\n\r\n  UTXOs = UTXOs.filter((UTXO) => isUTXOInMempool(mempool, UTXO) === false);\r\n\r\n  const enoughRavencoinUTXOs = getEnoughUTXOs(\r\n    UTXOs,\r\n    isAssetTransfer ? 1 : amount + MAX_FEE\r\n  );\r\n\r\n  //Sum up the whole unspent amount\r\n  let unspentRavencoinAmount = sumOfUTXOs(enoughRavencoinUTXOs);\r\n  if (unspentRavencoinAmount <= 0) {\r\n    throw Error(\r\n      \"Not enough RVN to transfer asset, perhaps your wallet has pending transactions\"\r\n    );\r\n  }\r\n  console.log(\r\n    \"Total amount of UTXOs Ravencon being used in this transaction\",\r\n    unspentRavencoinAmount.toLocaleString(),\r\n    amount.toLocaleString()\r\n  );\r\n  if (isAssetTransfer === false) {\r\n    if (amount > unspentRavencoinAmount) {\r\n      throw Error(\r\n        \"Insufficient funds, cant send \" +\r\n          amount.toLocaleString() +\r\n          \" only have \" +\r\n          unspentRavencoinAmount.toLocaleString()\r\n      );\r\n    }\r\n  }\r\n\r\n  const rvnAmount = isAssetTransfer ? 0 : amount;\r\n\r\n  const inputs = blockchain.convertUTXOsToVOUT(enoughRavencoinUTXOs);\r\n  const outputs: any = {};\r\n  //Add asset inputs\r\n  if (isAssetTransfer === true) {\r\n    await addAssetInputsAndOutputs(\r\n      rpc,\r\n      addresses,\r\n      assetName,\r\n      amount,\r\n      inputs,\r\n      outputs,\r\n      toAddress,\r\n      assetChangeAddress\r\n    );\r\n  } else if (isAssetTransfer === false) {\r\n    outputs[toAddress] = rvnAmount;\r\n  }\r\n\r\n  const fee = await getFee(rpc, inputs, outputs);\r\n  console.log(\"Fee for sending\", assetName, fee);\r\n  console.log(\"Unspent RVN\", unspentRavencoinAmount);\r\n  console.log(\"rvnAmount\", rvnAmount);\r\n  console.log(\"Fee\", fee);\r\n  const ravencoinChangeAmount = unspentRavencoinAmount - rvnAmount - fee;\r\n\r\n  console.log(\"Ravencoin chnage amount\", ravencoinChangeAmount);\r\n\r\n  //Obviously we only add change address if there is any change\r\n  if (getTwoDecimalTrunc(ravencoinChangeAmount) > 0) {\r\n    outputs[ravencoinChangeAddress] = getTwoDecimalTrunc(ravencoinChangeAmount);\r\n  }\r\n  //Now we have enough UTXos, lets create a raw transactions\r\n\r\n  const raw = await blockchain.createRawTransaction(rpc, inputs, outputs);\r\n\r\n  //OK lets find the private keys (WIF) for input addresses\r\n  type TPrivateKey = {\r\n    [key: string]: string;\r\n  };\r\n  const privateKeys: TPrivateKey = {};\r\n  inputs.map(function (input: IVout_when_creating_transactions) {\r\n    const addy = input.address;\r\n    const addressObject = fromAddressObjects.find((a) => a.address === addy);\r\n    if (addressObject) {\r\n      privateKeys[addy] = addressObject.WIF;\r\n    }\r\n  });\r\n\r\n  //Sign the transaction\r\n  const keys: Array<string> = Object.values(privateKeys);\r\n  const signedTransactionPromise = blockchain.signRawTransaction(\r\n    rpc,\r\n    raw,\r\n    keys\r\n  );\r\n  signedTransactionPromise.catch((e: any) => {\r\n    console.dir(e);\r\n  });\r\n\r\n  const signedTransaction = await signedTransactionPromise;\r\n\r\n  const txid = await blockchain.sendRawTransaction(rpc, signedTransaction);\r\n  return txid;\r\n}\r\n\r\nasync function addAssetInputsAndOutputs(\r\n  rpc: RPCType,\r\n  addresses: string[],\r\n  assetName: string,\r\n  amount: number,\r\n  inputs: IVout_when_creating_transactions[],\r\n  outputs: any,\r\n  toAddress: string,\r\n  assetChangeAddress: string\r\n) {\r\n  let assetUTXOs = await blockchain.getAssetUnspentTransactionOutputs(\r\n    rpc,\r\n    addresses,\r\n    assetName\r\n  );\r\n\r\n  const mempool = await blockchain.getMempool(rpc);\r\n  assetUTXOs = assetUTXOs.filter(\r\n    (UTXO) => isUTXOInMempool(mempool, UTXO) === false\r\n  );\r\n\r\n  const _UTXOs = getEnoughUTXOs(assetUTXOs, amount);\r\n  const tempInputs = blockchain.convertUTXOsToVOUT(_UTXOs);\r\n  tempInputs.map((item) => inputs.push(item));\r\n\r\n  outputs[toAddress] = {\r\n    transfer: {\r\n      [assetName]: amount,\r\n    },\r\n  };\r\n\r\n  const assetSum = sumOfUTXOs(_UTXOs);\r\n\r\n  //Only add change address if needed\r\n  if (assetSum - amount > 0) {\r\n    outputs[assetChangeAddress] = {\r\n      transfer: {\r\n        [assetName]: assetSum - amount,\r\n      },\r\n    };\r\n  }\r\n}\r\n\r\nfunction getTwoDecimalTrunc(num: number) {\r\n  //Found answer here https://stackoverflow.com/questions/11832914/how-to-round-to-at-most-2-decimal-places-if-necessary\r\n  //In JavaScript the number 77866.98 minus 111 minus 0.2 equals 77755.95999999999\r\n  //We want it to be 77755.96\r\n  return Math.trunc(num * 100) / 100;\r\n}\r\n\r\nexport async function send(\r\n  rpc: RPCType,\r\n  fromAddressObjects: Array<IAddressMetaData>,\r\n  toAddress: string,\r\n  amount: number,\r\n  assetName: string\r\n) {\r\n  return _send({ rpc, fromAddressObjects, toAddress, amount, assetName });\r\n}\r\n\r\nfunction getEnoughUTXOs(utxos: Array<IUTXO>, amount: number): Array<IUTXO> {\r\n  let tempAmount = 0;\r\n  const returnValue: Array<IUTXO> = [];\r\n\r\n  utxos.map(function (utxo) {\r\n    if (utxo.satoshis !== 0 && tempAmount < amount) {\r\n      const value = utxo.satoshis / 1e8;\r\n      tempAmount = tempAmount + value;\r\n      returnValue.push(utxo);\r\n    }\r\n  });\r\n  return returnValue;\r\n}\r\n\r\nexport function isUTXOInMempool(\r\n  mempool: Array<ITransaction>,\r\n  UTXO: IUTXO\r\n): boolean {\r\n  function format(transactionId: string, index: number) {\r\n    return transactionId + \"_\" + index;\r\n  }\r\n\r\n  const listOfUTXOsInMempool: Array<string> = [];\r\n  mempool.map((transaction) => {\r\n    transaction.vin.map((vin) => {\r\n      const id = format(vin.txid, vin.vout);\r\n      listOfUTXOsInMempool.push(id);\r\n    });\r\n  });\r\n\r\n  const index = listOfUTXOsInMempool.indexOf(\r\n    format(UTXO.txid, UTXO.outputIndex)\r\n  );\r\n  const isInMempool = index > -1;\r\n\r\n  return isInMempool;\r\n}\r\n","import {\r\n  IUTXO,\r\n  IValidateAddressResponse,\r\n  IVout,\r\n  IVout_when_creating_transactions,\r\n  RPCType,\r\n} from \"../Types\";\r\nimport { ITransaction } from \"../Types\";\r\n\r\nconst ONE_HUNDRED_MILLION = 1e8;\r\n\r\nexport function getAddressDeltas(rpc: RPCType, addresses: string[]) {\r\n  return rpc(\"getaddressdeltas\", [\r\n    {\r\n      addresses: addresses,\r\n      assetName: \"\",\r\n    },\r\n  ]);\r\n}\r\nexport function sendRawTransaction(rpc: RPCType, signedTransaction: any) {\r\n  const p = rpc(\"sendrawtransaction\", [signedTransaction.hex]);\r\n  p.catch((e: any) => {\r\n    console.log(\"send raw transaction\");\r\n    console.dir(e);\r\n  });\r\n  return p;\r\n}\r\nexport function signRawTransaction(\r\n  rpc: RPCType,\r\n  rawTransactionHex: any,\r\n  privateKeys: Array<string>\r\n) {\r\n  const s = rpc(\"signrawtransaction\", [\r\n    rawTransactionHex,\r\n    null,\r\n    privateKeys,\r\n  ]);\r\n  return s;\r\n}\r\n\r\nexport function decodeRawTransaction(rpc: RPCType, raw: string) {\r\n  return rpc(\"decoderawtransaction\", [raw]);\r\n}\r\n\r\nexport function getRawTransaction(rpc: RPCType, id: string): any {\r\n  return rpc(\"getrawtransaction\", [id, true]);\r\n}\r\nexport function createRawTransaction(\r\n  rpc: RPCType,\r\n  inputs: any,\r\n  outputs: any\r\n): Promise<string> {\r\n  return rpc(\"createrawtransaction\", [inputs, outputs]);\r\n}\r\n\r\nexport async function validateAddress(\r\n  rpc: RPCType,\r\n  address: string\r\n): Promise<IValidateAddressResponse> {\r\n  return rpc(\"validateaddress\", [address]);\r\n}\r\nexport function getBalance(\r\n  rpc: RPCType,\r\n  addresses: Array<string>\r\n): Promise<any> {\r\n  const includeAssets = true;\r\n  const promise = rpc(\"getaddressbalance\", [\r\n    { addresses: addresses },\r\n    includeAssets,\r\n  ]);\r\n  return promise;\r\n}\r\n\r\nexport function _sortUTXOs(list: Array<IUTXO>) {\r\n  //Remember, sort mutates the underlaying array\r\n  //Sort by satoshis, lowest first to prevent dust.\r\n  return list.sort(function (a, b) {\r\n    if (a.satoshis > b.satoshis) {\r\n      return 1;\r\n    }\r\n    if (a.satoshis < b.satoshis) {\r\n      return -1;\r\n    }\r\n    return 0;\r\n  });\r\n}\r\nexport async function getRavenUnspentTransactionOutputs(\r\n  rpc: RPCType,\r\n  addresses: Array<string>\r\n): Promise<Array<IUTXO>> {\r\n  const list: Array<IUTXO> = await rpc(\"getaddressutxos\", [\r\n    { addresses },\r\n  ]);\r\n  _sortUTXOs(list);\r\n  return list;\r\n}\r\nexport function getAssetUnspentTransactionOutputs(\r\n  rpc: RPCType,\r\n  addresses: Array<string>,\r\n  assetName: string\r\n): Promise<Array<IUTXO>> {\r\n  const assets = rpc(\"getaddressutxos\", [{ addresses, assetName }]);\r\n  return assets;\r\n}\r\n\r\nexport function getAllUnspentTransactionOutputs(\r\n  rpc: RPCType,\r\n  addresses: Array<string>\r\n) {\r\n  /*\r\n  Seems like getaddressutxos either return RVN UTXOs or asset UTXOs\r\n  Never both.\r\n  So we make two requests and we join the answer\r\n  */\r\n  const raven = rpc(\"getaddressutxos\", [{ addresses }]);\r\n  const assets = rpc(\"getaddressutxos\", [{ addresses, assetName: \"*\" }]);\r\n\r\n  return Promise.all([raven, assets]).then((values: Array<any>) => {\r\n    const all = values[0].concat(values[1]);\r\n    return all;\r\n  });\r\n}\r\nexport async function getMempool(rpc: RPCType): Promise<Array<ITransaction>> {\r\n  const ids = await rpc(\"getrawmempool\", []);\r\n\r\n  const result: any = [];\r\n  for (const id of ids) {\r\n    const transaction = await getRawTransaction(rpc, id);\r\n    result.push(transaction);\r\n  }\r\n  return result;\r\n}\r\nexport function convertUTXOsToVOUT(\r\n  UTXOs: Array<IUTXO>\r\n): Array<IVout_when_creating_transactions> {\r\n  const inputs = UTXOs.map(function (bla) {\r\n    //OK we have to convert from \"unspent\" format to \"vout\"\r\n\r\n    const obj = {\r\n      txid: bla.txid,\r\n      vout: bla.outputIndex,\r\n      address: bla.address,\r\n    };\r\n    return obj;\r\n  });\r\n  return inputs;\r\n}\r\n"],"names":[],"version":3,"file":"index.mjs.map"}